# Экран 3.1: Item Screen (Просмотр записи)

## Обзор

Item Screen предназначен для просмотра полной информации о событии и количества прошедших дней. Экран отображает все детали записи в структурированном виде.

## Назначение

Просмотр полной информации о событии и количества прошедших дней с возможностью перехода к редактированию записи.

## Компоненты

1. **Заголовок экрана** — количество дней с момента события (вычисляется динамически, navigationTitle)
2. **Режим просмотра** (regularView):
   - **Секция "Название"** (ReadSectionView)
     - Заголовок: "Название" (SectionTitleView)
     - Текст: название события
   - **Секция "Описание"** (если есть текст, ReadSectionView)
     - Заголовок: "Описание" (SectionTitleView)
     - Текст: описание события
   - **Цветовая метка** (если задана)
     - ColorPicker в режиме только просмотра (disabled)
     - Заголовок: "Цветовая метка"
   - **Дата события** (ItemDatePicker)
     - DatePicker в режиме только просмотра (disabled)
     - Заголовок: "Дата"
   - **Опция отображения** (ItemDisplayOptionPicker)
     - Picker в режиме только просмотра (disabled)
     - Заголовок: "Формат отображения"
     - Текст: локализованное название формата
3. **Режим редактирования** (EditItemScreen):
   - Переключение между режимами с анимацией (transition)
   - In-place редактирование (как в iOS) или отдельный экран

## Кнопки на Toolbar

- **Кнопка редактирования** (справа на Toolbar, placement: topBarTrailing)
  - Текст: "Редактировать" (labelStyle: titleOnly)
  - Переключает экран в режим редактирования (in-place с анимацией, как в iOS)
- **Кнопка назад** (слева на Toolbar, автоматически через NavigationStack)
  - Возврат к списку записей

## Навигация

- Кнопка "Назад" → Экран 2.1 (Main Screen)
- Кнопка "Редактировать" → Экран 4.1 (Edit Item Screen)

**Примечание:** Навигация к этому экрану должна быть реализована из Main Screen при клике на запись в списке.

## Зависимости от других этапов

- ⚠️ **Требуется Этап 7**: Модель данных (Entity, Domain model, Room Database, DAO) — необходимо для получения данных записи
- ⚠️ **Требуется Этап 6**: Форматирование количества дней — необходимо для отображения заголовка экрана
- ⚠️ **Требуется Экран 2.1**: Main Screen — должен быть реализован для навигации к Item Screen

---

## Подробный план реализации по TDD

### Предварительные требования

Перед началом реализации этого экрана должны быть выполнены:
1. **Этап 7**: Модель данных (Entity, Domain model, Room Database, DAO)
2. **Этап 6**: Форматирование количества дней (функция вычисления и форматирования)
3. **Экран 2.1**: Main Screen (хотя бы базовая реализация для навигации)

---

### Шаг 1: Подготовка навигации

#### 1.1. Добавление маршрута

**Задачи:**
1. Добавить маршрут ItemDetails в Screen.kt
   - Формат: `object ItemDetails : Screen("item_details/{itemId}", icon, titleResId)`
   - Использовать `titleResId` для локализации (если требуется заголовок экрана)
   - Метод `createRoute(itemId: Long)` для создания маршрута с параметром
2. Написать тесты для проверки корректности маршрута

**Примечание:** Для экранов без постоянного заголовка в навигации (например, ItemDetails с динамическим заголовком) можно использовать заглушку или не указывать titleResId, если заголовок задается динамически через navigationTitle.

**Критерии готовности:**
- ✅ Маршрут добавлен
- ✅ Метод создания маршрута реализован
- ✅ Тесты написаны и проходят

---

#### 1.2. Настройка навигации в RootScreen

**Задачи:**
1. Добавить composable для маршрута item_details в NavHost
2. Реализовать передачу itemId через аргументы навигации
3. Настроить навигацию из Main Screen к Item Screen

**Критерии готовности:**
- ✅ Навигация настроена
- ✅ Передача параметров работает
- ✅ Навигация из Main Screen работает

---

### Шаг 2: Подготовка слоя домена (Domain Layer)

#### 2.1. Use Case для получения записи

**Задачи:**
1. Создать GetItemByIdUseCase
   - Принимает itemId: Long
   - Возвращает Flow<Item?> или Result<Item>
   - Использует ItemRepository
2. Написать unit-тесты для Use Case:
   - `whenItemExists_thenReturnsItem()`
   - `whenItemNotFound_thenReturnsNull()`
   - `whenRepositoryError_thenReturnsError()`

**Критерии готовности:**
- ✅ Use Case создан
- ✅ Unit-тесты написаны и проходят

---

### Шаг 3: Подготовка слоя представления (Presentation Layer)

#### 3.1. UI State

**Задачи:**
1. Создать data class ItemScreenState
   - Поля: item (Item?), isLoading (Boolean), error (String?)
2. Создать sealed class для состояний (Loading, Success, Error)
3. Написать тесты для UI State

**Структура:**
```kotlin
sealed class ItemScreenUiState {
    object Loading : ItemScreenUiState()
    data class Success(val item: Item) : ItemScreenUiState()
    data class Error(val message: String) : ItemScreenUiState()
}

data class ItemScreenState(
    val item: Item? = null,
    val uiState: ItemScreenUiState = ItemScreenUiState.Loading
)
```

**Критерии готовности:**
- ✅ UI State создан
- ✅ Sealed class создан
- ✅ Unit-тесты написаны и проходят

---

#### 3.2. ViewModel

**Задачи:**
1. Создать ItemScreenViewModel
   - Инициализация: загрузка записи по ID из аргументов навигации
   - Обработка состояний загрузки (Loading/Success/Error)
   - Обработка ошибок (запись не найдена)
2. Написать unit-тесты:
   - `whenViewModelCreated_thenLoadsItemById()`
   - `whenItemLoaded_thenUpdatesStateToSuccess()`
   - `whenItemNotFound_thenUpdatesStateToError()`
   - `whenLoadError_thenUpdatesStateToError()`

**Критерии готовности:**
- ✅ ViewModel создан
- ✅ Все методы реализованы
- ✅ Unit-тесты написаны и проходят

---

### Шаг 4: Реализация UI компонентов

#### 4.1. Компонент секции записи

**Задачи:**
1. Создать ReadSectionView composable (аналог iOS ReadSectionView)
   - Заголовок секции (SectionTitleView - bold, alignment: leading)
   - Содержимое секции (Text)
   - VStack с spacing: 8dp, alignment: leading
   - Поддержка условного отображения (если содержимое пустое)
   - Верстка идентична iOS для единообразия UX
2. Создать SectionTitleView composable (аналог iOS SectionTitleView)
   - Bold текст
   - ForegroundStyle: primary (если enabled) или secondary (если disabled)
   - Alignment: leading
3. Написать Preview для секций

**Критерии готовности:**
- ✅ Section composable создан
- ✅ Условное отображение работает
- ✅ Preview работает

---

#### 4.2. Компонент отображения цветовой метки

**Задачи:**
1. Создать ColorTagIndicator composable
   - Круглый индикатор с цветом
   - Условное отображение (если colorTag задан)
2. Написать Preview для цветовой метки

**Критерии готовности:**
- ✅ ColorTagIndicator создан
- ✅ Условное отображение работает
- ✅ Preview работает

---

#### 4.3. Компонент заголовка с количеством дней

**Задачи:**
1. Создать DaysCountHeader composable
   - Отображение количества дней (используя функцию форматирования из Этапа 6)
   - Динамическое обновление
2. Написать Preview для заголовка

**Критерии готовности:**
- ✅ DaysCountHeader создан
- ✅ Форматирование работает
- ✅ Preview работает

---

#### 4.4. TopAppBar с кнопками

**Задачи:**
1. Реализовать TopAppBar с:
   - Кнопкой "Назад" (слева)
   - Кнопкой "Редактировать" (справа, иконка карандаша)
2. Обработать клики на кнопки (навигация)
3. Написать Preview для TopAppBar

**Критерии готовности:**
- ✅ TopAppBar реализован
- ✅ Навигация работает
- ✅ Preview работает

---

#### 4.5. Главный экран ItemScreen

**Задачи:**
1. Создать ItemScreen composable
   - Подключить к ViewModel
   - Использовать ScrollView для прокрутки содержимого
   - Реализовать переключение между режимами просмотра и редактирования:
     - ZStack с двумя состояниями: regularView и EditItemScreen
     - Анимация перехода (transition: move + scale + opacity)
     - State для управления режимом редактирования
   - Отобразить TopAppBar с кнопкой редактирования
   - Обработать состояния (Loading/Success/Error)
   - Отобразить все секции записи в режиме просмотра:
     - Заголовок с количеством дней (navigationTitle)
     - Секция "Название" (ReadSectionView)
     - Секция "Описание" (ReadSectionView, условно, если есть текст)
     - Цветовая метка (ColorPicker disabled, условно, если задана)
     - Дата события (ItemDatePicker disabled)
     - Опция отображения дней (ItemDisplayOptionPicker disabled)
   - Реализовать in-place редактирование (как в iOS) или переход к отдельному экрану
   - Обработать ошибку (запись не найдена)
2. Интегрировать с навигацией (NavController)
3. Написать Preview для ItemScreen

**Критерии готовности:**
- ✅ ItemScreen создан
- ✅ Все секции отображаются корректно
- ✅ Обработка ошибок работает
- ✅ Preview работает

---

### Шаг 5: Интеграция с навигацией

#### 5.1. Навигация из Main Screen

**Задачи:**
1. Добавить обработку клика на запись в Main Screen
2. Реализовать переход к Item Screen с передачей itemId
3. Проверить корректную работу навигации

**Критерии готовности:**
- ✅ Навигация из Main Screen работает
- ✅ Передача itemId работает

---

#### 5.2. Навигация к экрану редактирования

**Задачи:**
1. Реализовать переход к Edit Item Screen при клике на кнопку "Редактировать"
2. Передать itemId в экран редактирования
3. Обработать возврат из экрана редактирования (обновление данных)

**Критерии готовности:**
- ✅ Навигация к Edit Screen работает
- ✅ Обновление данных после редактирования работает

---

### Шаг 6: Дополнительные функции

#### 6.1. Обработка ошибок

**Задачи:**
1. Реализовать отображение сообщения об ошибке (запись не найдена)
2. Добавить возможность вернуться к списку при ошибке
3. Написать тесты для обработки ошибок

**Критерии готовности:**
- ✅ Обработка ошибок реализована
- ✅ Тесты написаны и проходят

---

#### 6.2. Локализация

**Задачи:**
1. Использовать готовые строковые ресурсы из `Localization_Plan.md`:
   - Заголовки секций: `title`, `details`, `date`, `color_tag`, `display_format`
   - Опции отображения дней: `days_only`, `months_and_days`, `years_months_and_days`
   - Кнопки: `edit`, `save`, `cancel`
   - Специальные значения: `today`
2. Поддержка русского и английского языков (уже реализована в `Localization_Plan.md`)

**Критерии готовности:**
- ✅ Используются готовые строковые ресурсы
- ✅ Локализация работает корректно

**Примечание:** План локализации готов в документе `Localization_Plan.md`. Все строки определены и готовы к использованию.

---

### Шаг 7: Финальное тестирование

**Задачи:**
1. Проверить правильное отображение всех полей записи (unit + UI тесты)
2. Проверить корректное вычисление и отображение количества дней (unit + UI тесты)
3. Проверить отображение цветовой метки (UI тесты)
4. Проверить функциональность кнопки редактирования (UI тесты)
5. Проверить корректную навигацию назад (UI тесты)
6. Проверить обработку ошибок (запись не найдена) (unit + UI тесты)
7. Проверить условное отображение секций (если поля пустые) (UI тесты)

**Критерии готовности:**
- ✅ Все тесты проходят
- ✅ Все функции работают корректно

---

## Реализация (детали)

### UI компоненты
- Использовать ScrollView для прокрутки содержимого (scrollBounceBehavior: basedOnSize)
- Использовать вертикальный VStack для основного макета (spacing: 20dp, alignment: leading)
- Реализовать переключение между режимами просмотра и редактирования:
  - ZStack с двумя состояниями
  - Анимация перехода (transition: move + scale + opacity)
- Добавить отображение заголовка с количеством дней (navigationTitle, используя функцию форматирования)
- Добавить секции с заголовками и содержимым (ReadSectionView + SectionTitleView)
  - VStack с spacing: 8dp
  - SectionTitleView: bold, foregroundStyle (primary/secondary), alignment: leading
- Добавить цветовую метку (ColorPicker в режиме disabled, если задана)
- Добавить DatePicker в режиме disabled (ItemDatePicker)
- Добавить Picker для опции отображения в режиме disabled (ItemDisplayOptionPicker)
- Обеспечить адекватное отображение текста с учетом длины
- Обеспечить адаптивность компоновки при изменении ориентации экрана
- Использовать TopAppBar для кнопок навигации и действий
- Реализовать обработку состояний (Loading/Success/Error)
- Подключить к ViewModel для получения данных записи (collectAsStateWithLifecycle)
- Использовать современные компоненты Material Design 3
- Применить тему приложения с поддержкой темного режима
- Применить корректные иконки из Material Icons
- Верстка идентична iOS для единообразия UX

### Архитектура
- Использовать Room для локального хранения данных (через Repository)
- Реализовать Repository Pattern для абстракции источников данных
- Использовать Flow для реактивного обновления UI
- Применить Clean Architecture (Data → Domain → Presentation)
- Использовать Use Cases для бизнес-логики

---

## Тестирование

### Unit-тесты
- Тесты для GetItemByIdUseCase
- Тесты для ItemScreenViewModel (логика загрузки, обработка ошибок)
- Тесты для UI State

### Интеграционные тесты
- Тесты взаимодействия ViewModel с Use Case
- Тесты взаимодействия Use Case с Repository

### UI-тесты
- Проверить отображение всех полей записи
- Проверить корректное вычисление и отображение количества дней
- Проверить отображение цветовой метки
- Проверить функциональность кнопки редактирования
- Проверить корректную навигацию назад
- Проверить обработку ошибок (запись не найдена)
- Проверить условное отображение секций

---

## Критерии завершения этапа

Этап считается завершенным, когда:

- ✅ Все компоненты созданы и работают
- ✅ Все unit-тесты написаны и проходят
- ✅ Все интеграционные тесты написаны и проходят
- ✅ Все UI-тесты написаны и проходят
- ✅ Код соответствует правилам проекта
- ✅ Линтеры не выдают ошибок
- ✅ Навигация работает корректно
- ✅ Обработка ошибок реализована

---

## Блокируемые этапы

После завершения этого экрана можно приступать к:
- Экран 4.1: Create/Edit Item Screen (требует навигацию из Item Screen для редактирования)

---

## Примечания

1. **Динамическое обновление**: Заголовок с количеством дней должен обновляться динамически при изменении текущей даты.

2. **Условное отображение**: Секции с пустым содержимым (например, описание) не должны отображаться.

3. **Обработка ошибок**: При ошибке загрузки записи пользователь должен иметь возможность вернуться к списку.

4. **Тестирование**: Все компоненты должны быть покрыты тестами перед использованием в других этапах.

5. **Зависимости**: Реализация зависит от завершения Этапа 7 (Модель данных), Этапа 6 (Форматирование дней) и Экрана 2.1 (Main Screen).
