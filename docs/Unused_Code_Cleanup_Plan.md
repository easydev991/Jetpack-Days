# План удаления неиспользуемого кода

**Дата создания:** 2 января 2026

## Обзор

В проекте обнаружен неиспользуемый код, который необходимо либо начать использовать, либо удалить. Данный документ содержит подробный план по анализу и очистке кода.

---

## Категории неиспользуемого кода

### 1. Неиспользуемые функции DI в `AppModule.kt`

#### 1.1 `fun createMainScreenViewModel(repository: ItemRepository)`

**Местоположение:** `app/src/main/java/com/dayscounter/di/AppModule.kt:42`

**Описание:** Factory-метод для создания `MainScreenViewModel`

**Анализ использования:**
- Не используется ни в одном файле проекта
- Вместо этого используется `MainScreenViewModel.factory` внутри ViewModel

**Рекомендация:** Удалить, так как фабрика создана внутри `MainScreenViewModel` и более удобна для использования с Jetpack Compose Navigation

**Шаги:**
1. Удалить функцию `createMainScreenViewModel`
2. Удалить связанную документацию

---

#### 1.2 `fun createDetailScreenViewModelFactory(repository: ItemRepository)`

**Местоположение:** `app/src/main/java/com/dayscounter/di/AppModule.kt:50-57`

**Описание:** Factory-функция для создания `DetailScreenViewModel` с параметрами

**Анализ использования:**
- Не используется ни в одном файле проекта
- Нужно проверить, как создается `DetailScreenViewModel` в навигации

**Рекомендация:**
- **Вариант 1 (предпочтительный):** Удалить, если не планируется использование
- **Вариант 2:** Если необходимо использовать, интегрировать в навигацию Compose

**Шаги:**
1. Проверить, как создается `DetailScreenViewModel` в навигации
2. Если используется другой подход, удалить эту функцию
3. Обновить документацию DI

---

#### 1.3 `fun createCreateEditScreenViewModelFactory(repository: ItemRepository)`

**Местоположение:** `app/src/main/java/com/dayscounter/di/AppModule.kt:65-74`

**Описание:** Factory-функция для создания `CreateEditScreenViewModel` с параметрами

**Анализ использования:**
- Не используется ни в одном файле проекта
- Нужно проверить, как создается `CreateEditScreenViewModel` в навигации

**Рекомендация:**
- **Вариант 1 (предпочтительный):** Удалить, если не планируется использование
- **Вариант 2:** Если необходимо использовать, интегрировать в навигацию Compose

**Шаги:**
1. Проверить, как создается `CreateEditScreenViewModel` в навигации
2. Если используется другой подход, удалить эту функцию
3. Обновить документацию DI

---

#### 1.4 `fun getFormatterModule(): FormatterModule`

**Местоположение:** `app/src/main/java/com/dayscounter/di/AppModule.kt:81`

**Описание:** Возвращает `FormatterModule`

**Анализ использования:**
- Не используется ни в одном файле проекта
- `FormatterModule` используется напрямую как объект

**Рекомендация:** Удалить, так как `FormatterModule` - это `object`, который может использоваться напрямую

**Шаги:**
1. Удалить функцию `getFormatterModule`
2. Проверить, что `FormatterModule` используется напрямую через `FormatterModule.create*()` методы
3. Удалить связанную документацию

---

### 2. Неиспользуемая ViewModel и её методы

#### 2.1 `DaysCalculatorViewModel` полностью

**Местоположение:** `app/src/main/java/com/dayscounter/viewmodel/DaysCalculatorViewModel.kt`

**Описание:** ViewModel для вычисления и форматирования разницы между датами

**Анализ использования:**
- Используется только в тестах (`DaysCalculatorViewModelTest`)
- Не используется в UI (ни один экран не использует эту ViewModel)

**Рекомендация:**
- **Вариант 1:** Удалить всю ViewModel и её тесты, если функциональность дублируется в других местах
- **Вариант 2:** Интегрировать в существующие ViewModels, если функциональность полезна

**Анализ альтернатив:**
- Проверить, используется ли функциональность в `DetailScreenViewModel` или других ViewModels
- Если да - удалить `DaysCalculatorViewModel` как дубликат
- Если нет - возможно, функциональность нужна для будущего использования

**Шаги:**
1. Проанализировать функциональность `DaysCalculatorViewModel`
2. Проверить, используется ли она в других ViewModels
3. Если дублируется - удалить ViewModel и тесты
4. Если нужна - интегрировать в нужный экран
5. Обновить документацию (`Stage_6_Days_Formatting_Implementation_Plan.md`, `Test_Migration_Plan.md`)

---

#### 2.2 `fun refresh(eventTimestamp: Long)` в `DaysCalculatorViewModel`

**Местоположение:** `app/src/main/java/com/dayscounter/viewmodel/DaysCalculatorViewModel.kt:166-168`

**Описание:** Пересчитывает разницу для текущего времени

**Анализ использования:**
- Не вызывается ни в одном файле проекта
- Функция просто вызывает `calculateDays(eventTimestamp)` без дополнительных параметров
- Является обёрткой над `calculateDays`

**Рекомендация:**
- **Если ViewModel удаляется:** Удаляется вместе с ViewModel
- **Если ViewModel остаётся:** Удалить как избыточную функцию, использовать напрямую `calculateDays`

**Шаги:**
1. Если ViewModel остаётся - удалить метод `refresh`
2. Найти все места, где могло бы использоваться `refresh` и заменить на `calculateDays`

---

### 3. Неиспользуемые расширения и методы

#### 3.1 `fun Item.withDisplayOption(displayOption: DisplayOption)`

**Местоположение:** `app/src/main/java/com/dayscounter/domain/model/ItemExtensions.kt:35`

**Описание:** Создает копию `Item` с обновленным `displayOption`

**Анализ использования:**
- Не вызывается ни в одном файле проекта
- Возможно, нужна для функциональности изменения опции отображения

**Рекомендация:**
- **Вариант 1:** Удалить, если функциональность изменения displayOption реализована иначе
- **Вариант 2:** Если нужна - добавить использование в UI (например, при переключении опции отображения)

**Шаги:**
1. Проанализировать, как изменяется `displayOption` в приложении
2. Если используется другой подход - удалить расширение
3. Если нужно - добавить использование в соответствующие экраны
4. Обновить документацию моделей

---

### 4. Неиспользуемые поля и методы в ViewModels

#### 4.1 `private val _defaultDisplayOption` в `MainScreenViewModel`

**Местоположение:** `app/src/main/java/com/dayscounter/viewmodel/MainScreenViewModel.kt:62`

**Описание:** Выбранная опция отображения дней по умолчанию

**Анализ использования:**
- Поле создано (`_defaultDisplayOption`), но не используется
- Нет public getter для `defaultDisplayOption`
- Нет setter для изменения значения
- Весь список всегда отображается с индивидуальной опцией для каждого элемента

**Рекомендация:**
- **Вариант 1 (предпочтительный):** Удалить поле, так как опция отображения хранится в каждом `Item`
- **Вариант 2:** Если нужна функциональность "опция по умолчанию для новых элементов" - добавить getter и setter

**Шаги:**
1. Проверить, нужна ли опция отображения по умолчанию для новых элементов
2. Если нет - удалить поле
3. Если да - добавить getter/setter и использовать при создании новых элементов
4. Обновить документацию (`Screen_2.1_Main_Screen.md`)

---

#### 4.2 `private fun loadItems()` в `MainScreenViewModel`

**Местоположение:** `app/src/main/java/com/dayscounter/viewmodel/MainScreenViewModel.kt:124-137`

**Описание:** Загружает события из репозитория

**Анализ использования:**
- Не вызывается ни в одном месте
- Вместо этого используется `observeItems()` в `init` блоке
- Функциональность дублируется и заменена на реактивный подход

**Рекомендация:** Удалить, так как заменена на `observeItems()`

**Шаги:**
1. Удалить метод `loadItems`
2. Проверить, что `observeItems()` корректно загружает данные
3. Обновить документацию (`Screen_2.1_Main_Screen.md`)

---

### 5. Дублирующиеся файлы

#### 5.1 `CreateEditFormParams` в двух местах

**Местоположения:**
- `app/src/main/java/com/dayscounter/ui/screen/CreateEditFormParams.kt`
- `app/src/main/java/com/dayscounter/ui/screen/components/createedit/CreateEditFormParams.kt`

**Описание:** Параметры для формы создания/редактирования события

**Анализ использования:**
- Используется в `CreateEditFormContent.kt` и `CreateEditScreen.kt`
- Два файла с одинаковым содержимым

**Рекомендация:**
- Удалить дубликат `app/src/main/java/com/dayscounter/ui/screen/CreateEditFormParams.kt`
- Оставить `app/src/main/java/com/dayscounter/ui/screen/components/createedit/CreateEditFormParams.kt` (в подпапке `components`)

**Шаги:**
1. Убедиться, что оба файла идентичны
2. Проверить импорты во всех использующих файлах
3. Удалить дубликат
4. Обновить документацию (`Screen_4.1_Create_Edit_Item_Screen.md`)

---

## Общий порядок выполнения

### Этап 1: Анализ и подтверждение (1-2 часа)

1. [ ] Проанализировать каждый элемент неиспользуемого кода
2. [ ] Подтвердить, что код действительно не используется (запустить тесты)
3. [ ] Определить, какие элементы точно можно удалить
4. [ ] Определить, какие элементы могут быть полезны в будущем

### Этап 2: Удаление подтвержденного кода (2-3 часа)

1. [ ] Удалить неиспользуемые функции DI в `AppModule.kt`
2. [ ] Удалить `DaysCalculatorViewModel` и её тесты (если подтверждено)
3. [ ] Удалить неиспользуемые расширения (`Item.withDisplayOption`)
4. [ ] Удалить неиспользуемые поля и методы в `MainScreenViewModel`
5. [ ] Удалить дубликат файла `CreateEditFormParams`

### Этап 3: Тестирование (1-2 часа)

1. [ ] Запустить все unit-тесты
2. [ ] Запустить все интеграционные тесты
3. [ ] Убедиться, что приложение собирается и запускается
4. [ ] Протестировать критические сценарии в приложении

### Этап 4: Обновление документации (1-2 часа)

1. [ ] Обновить `docs/Screen_2.1_Main_Screen.md`
2. [ ] Обновить `docs/Screen_3.1_Item_Screen.md`
3. [ ] Обновить `docs/Screen_4.1_Create_Edit_Item_Screen.md`
4. [ ] Обновить `docs/Stage_6_Days_Formatting_Implementation_Plan.md`
5. [ ] Обновить `docs/Test_Migration_Plan.md`
6. [ ] Обновить документацию DI (если есть)
7. [ ] Удалить упоминания удаленного кода из всех документов

---

## Риски иMitigations

### Риск 1: Код, который кажется неиспользуемым, нужен для будущего функционала

**Mitigation:** Перед удалением проверить планы развития в документации, обсудить с командой

### Риск 2: Удаление кода сломает существующие тесты

**Mitigation:** После каждого удаления запускать тесты и исправлять ошибки

### Риск 3: Некорректный анализ использования кода

**Mitigation:** Использовать инструменты статического анализа (ktlint, detekt), проверить grep-ом все использования

### Риск 4: Удаление дубликата `CreateEditFormParams` сломает импорты

**Mitigation:** Проверить все импорты перед удалением, обновить при необходимости

---

## Критерии завершения

- [ ] Все элементы из списка анализа обработаны (удалены или интегрированы)
- [ ] Все тесты проходят успешно
- [ ] Приложение собирается без ошибок
- [ ] Все документации обновлены
- [ ] Нет предупреждений линтеров о неиспользуемом коде

---

## Дополнительные замечания

### Рекомендации по предотвращению появления неиспользуемого кода:

1. **Использовать инструменты статического анализа:** ktlint, detekt
2. **Регулярно запускать проверки:** включить в CI/CD
3. **Code Review:** внимательный анализ при добавлении нового кода
4. **TDD подход:** писать тесты до кода, писать только тот код, который нужен для прохождения тестов
5. **Рефакторинг:** регулярная очистка кода после завершения задач

### Инструменты для анализа:

- `./gradlew detekt` - статический анализ
- `./gradlew ktlintCheck` - проверка стиля кода
- IDE inspections - встроенная проверка IDE

---

## Связанная документация

- `docs/Screen_2.1_Main_Screen.md` - документация главного экрана
- `docs/Screen_3.1_Item_Screen.md` - документация экрана деталей
- `docs/Screen_4.1_Create_Edit_Item_Screen.md` - документация экрана создания/редактирования
- `docs/Stage_6_Days_Formatting_Implementation_Plan.md` - план форматирования дней
- `docs/Test_Migration_Plan.md` - план миграции тестов
- `docs/Hilt_Setup_Plan.md` - план настройки Hilt (если будет использоваться)

---

## Примечания

- Перед удалением каждого элемента необходимо убедиться, что он действительно не нужен
- Удалять код небольшими частями, после каждого удаления запускать тесты
- Документацию обновлять параллельно с изменениями в коде
- Все изменения должны проходить через code review

---

**Последнее обновление:** 2 января 2026
**Статус:** План на утверждении, awaiting execution
