# Экран 2.1: Main Screen (Главный экран)

## Обзор

Main Screen является основным экраном приложения для отображения списка всех записей о событиях. Экран предоставляет функциональность поиска, сортировки и управления записями.

## Назначение

Отображение списка всех записей о событиях с возможностью поиска, сортировки и навигации к деталям записи или созданию новой записи.

## Компоненты

1. **Заголовок экрана** — "События"
2. **Кнопка сортировки** (если более 1 записи)
   - Позиция: слева на Toolbar (topBarLeading)
   - Опции: "Старые первые" / "Новые первые" (как в iOS: SortOrder.forward/reverse)
   - Сортировка по дате события (timestamp)
   - Меню с Picker для выбора опции сортировки
3. **Поле поиска**
   - Позиция: в NavigationBar (как в iOS - navigationBarDrawer)
   - Поиск по названию и описанию записи
   - Фильтрация списка в реальном времени
   - Автоматическое отображение/скрытие при прокрутке (displayMode: automatic)
4. **Кнопка добавления записи**
   - Позиция: справа на Toolbar
   - Иконка: "+"
   - Открывает экран создания новой записи
5. **Список записей** (LazyColumn)
   - Карточка каждой записи содержит:
     - Название события
     - Количество дней с момента события (отформатированное)
     - Дата события
     - Цветовая метка (если задана)
   - Клик по карточке — переход к деталям записи
6. **Пустое состояние** (если нет записей)
   - Иконка: Material Icons (аналог "tray.fill")
   - Заголовок: "Что запомнить?"
   - Описание: "Создайте первую запись"
   - Кнопка: "Добавить запись"

## Взаимодействия

- **Свайп-действия** (как в iOS):
  - Свайп влево/вправо — открытие меню с кнопками "Удалить" и "Редактировать"
  - Кнопка "Удалить" — удаление записи
  - Кнопка "Редактировать" — переход к экрану редактирования
- **Клик по записи** — переход к экрану деталей (Item Screen)

## Навигация

- Клик на запись → Screen 3.1 (Item Screen)
- Кнопка "+" → Screen 4.1 (Create Item Screen)
- Из контекстного меню: "Редактировать" → Screen 4.1 (Edit Item Screen)

## Зависимости от других этапов

- ✅ **Этап 7**: Модель данных (Entity, Domain model, Room Database, DAO) — **ЗАВЕРШЕН**, готов к использованию
- ⚠️ **Требуется Этап 6**: Форматирование количества дней — необходимо для отображения количества дней в списке
- ⚠️ **Требуется Экран 1.1**: Root Screen — должен быть реализован для навигации к Main Screen

---

## Подробный план реализации по TDD

### Шаг 1: Подготовка слоя данных (Data Layer)

#### 1.1. Модель данных Room Entity

**Задачи:**
1. Создать Room Entity для записи события (ItemEntity)
   - Поля: id, title, details, timestamp, colorTag, displayOption
   - Индексы для оптимизации запросов
2. Написать тесты для проверки корректности Entity

**Критерии готовности:**
- ✅ Room Entity создана
- ✅ Поля определены корректно
- ✅ Индексы добавлены
- ✅ Unit-тесты написаны и проходят

**Примечание:** ✅ Реализовано в Этапе 7.

---

#### 1.2. Room DAO

**Задачи:**
1. Создать ItemDao с методами:
   - `getAllItems(): Flow<List<ItemEntity>>`
   - `getItemById(id: Long): Flow<ItemEntity?>`
   - `insertItem(item: ItemEntity): Long`
   - `updateItem(item: ItemEntity)`
   - `deleteItem(id: Long)`
   - `searchItems(query: String): Flow<List<ItemEntity>>`
2. Написать тесты для DAO (используя in-memory database)

**Критерии готовности:**
- ✅ DAO создан со всеми методами
- ✅ Интеграционные тесты написаны и проходят

**Примечание:** ✅ Реализовано в Этапе 7.

---

#### 1.3. Room Database

**Задачи:**
1. Создать AppDatabase с миграциями
2. Настроить версионирование базы данных
3. Написать тесты для проверки миграций

**Критерии готовности:**
- ✅ Database создана
- ✅ Миграции настроены
- ✅ Тесты написаны и проходят

**Примечание:** ✅ Реализовано в Этапе 7.

---

### Шаг 2: Подготовка слоя домена (Domain Layer)

#### 2.1. Domain Entity

**Задачи:**
1. Создать data class Item (domain model)
   - Конвертация из/в ItemEntity
   - Метод для вычисления количества дней
2. Написать тесты для domain model

**Критерии готовности:**
- ✅ Domain model создана
- ✅ Конвертация реализована
- ✅ Unit-тесты написаны и проходят

**Примечание:** ✅ Реализовано в Этапе 7.

---

#### 2.2. Repository Interface

**Задачи:**
1. Создать интерфейс ItemRepository в domain слое
   - Методы для CRUD операций
   - Методы для поиска и сортировки
2. Написать тесты для интерфейса (контракт)

**Критерии готовности:**
- ✅ Интерфейс Repository создан
- ✅ Методы объявлены
- ✅ Unit-тесты написаны

**Примечание:** ✅ Реализовано в Этапе 7.

---

#### 2.3. Repository Implementation

**Задачи:**
1. Реализовать ItemRepositoryImpl в data слое
   - Использовать Room DAO
   - Преобразование между Entity и Domain model
2. Написать интеграционные тесты для Repository

**Критерии готовности:**
- ✅ Реализация Repository создана
- ✅ Интеграционные тесты написаны и проходят

**Примечание:** ✅ Реализовано в Этапе 7.

---

#### 2.4. Use Cases

**Задачи:**
1. Создать GetAllItemsUseCase
2. Создать SearchItemsUseCase
3. Создать DeleteItemUseCase
4. Написать unit-тесты для каждого Use Case

**Критерии готовности:**
- ✅ Use Cases созданы
- ✅ Unit-тесты написаны и проходят

---

### Шаг 3: Подготовка слоя представления (Presentation Layer)

#### 3.1. UI State

**Задачи:**
1. Создать data class MainScreenState
   - Список записей
   - Состояние поиска (query)
   - Состояние сортировки (SortOrder)
   - Состояние загрузки (Loading/Success/Error)
2. Создать sealed class для состояний (Loading, Success, Error)
3. Написать тесты для UI State

**Структура:**
```kotlin
sealed class MainScreenUiState {
    object Loading : MainScreenUiState()
    data class Success(val items: List<Item>) : MainScreenUiState()
    data class Error(val message: String) : MainScreenUiState()
}

data class MainScreenState(
    val items: List<Item> = emptyList(),
    val searchQuery: String = "",
    val sortOrder: SortOrder = SortOrder.DESCENDING,
    val uiState: MainScreenUiState = MainScreenUiState.Loading
)
```

**Критерии готовности:**
- ✅ UI State создан
- ✅ Sealed class для состояний создан
- ✅ Unit-тесты написаны и проходят

---

#### 3.2. ViewModel

**Задачи:**
1. Создать MainScreenViewModel
   - Инициализация: загрузка всех записей
   - Обработка поиска: фильтрация списка
   - Обработка сортировки: изменение порядка записей
   - Обработка удаления: удаление записи
2. Написать unit-тесты:
   - `whenViewModelCreated_thenLoadsAllItems()`
   - `whenSearchQueryChanged_thenFiltersItems()`
   - `whenSortOrderChanged_thenSortsItems()`
   - `whenItemDeleted_thenRemovesFromList()`
   - `whenNoItems_thenShowsEmptyState()`

**Критерии готовности:**
- ✅ ViewModel создан
- ✅ Все методы реализованы
- ✅ Unit-тесты написаны и проходят

---

### Шаг 4: Реализация UI компонентов

#### 4.1. Компонент карточки записи

**Задачи:**
1. Создать ListItemView composable (аналог iOS ListItemView)
   - Верстка: HStack (Row) с элементами:
     - Цветовая метка (круглый индикатор 16x16dp, слева) - условно, если задана
     - Название события (flexible, слева, maxLines: 2)
     - Количество дней (справа, multilineTextAlignment: trailing)
   - Адаптивность: использовать ViewThatFits или аналогичный механизм:
     - Первый вариант: количество дней с максимальной шириной
     - Второй вариант: количество дней с фиксированной шириной (30% экрана)
   - Отображение названия события
   - Отображение количества дней (отформатированное, с contentTransition для анимации)
   - Цветовая метка (круглый индикатор 16x16dp)
   - Верстка идентична iOS для единообразия UX
2. Написать Preview для карточки
3. Написать UI тесты для карточки

**Критерии готовности:**
- ✅ EventItemCard создан
- ✅ Все поля отображаются корректно
- ✅ Preview работает
- ✅ UI тесты написаны

---

#### 4.2. Компонент пустого состояния

**Задачи:**
1. Создать EmptyState composable (аналог iOS ContentUnavailableView)
   - Иконка: "tray.fill" (Material Icons)
   - Заголовок: "Что запомнить?" (What should we remember?)
   - Описание: "Создайте первую запись" (Create your first item)
   - Кнопка: "Добавить запись" (Add Item)
   - Анимация появления/исчезновения (scale + opacity transition)
   - Верстка идентична iOS для единообразия UX
2. Написать Preview для пустого состояния

**Критерии готовности:**
- ✅ EmptyState создан
- ✅ Preview работает

---

#### 4.3. Toolbar с поиском и сортировкой

**Задачи:**
1. Реализовать TopAppBar с:
   - Заголовком "События" (navigationTitle)
   - Кнопкой сортировки (если записей > 1, placement: topBarLeading)
     - Меню с Picker для выбора сортировки
     - Опции: "Старые первые" / "Новые первые"
   - Поле поиска в NavigationBar (searchable, placement: navigationBarDrawer, displayMode: automatic)
   - Кнопкой добавления "+" (placement: topBarTrailing)
2. Реализовать выпадающее меню (Menu) для сортировки с Picker
3. Написать Preview для Toolbar

**Критерии готовности:**
- ✅ TopAppBar реализован
- ✅ Поиск работает
- ✅ Сортировка работает
- ✅ Preview работает

---

#### 4.4. Главный экран MainScreen

**Задачи:**
1. Создать MainScreen composable
   - Подключить к ViewModel
   - Использовать NavigationStack (NavHost) для навигации
   - Отобразить TopAppBar с поиском, сортировкой и кнопкой добавления
   - Отобразить LazyColumn со списком записей или EmptyState
   - Реализовать свайп-действия (SwipeToDismiss или аналоги):
     - Кнопка "Удалить" (деструктивная, красная)
     - Кнопка "Редактировать"
   - Обработать клики по карточкам (NavigationLink к Item Screen)
   - Анимация списка при изменении данных
   - Пустое состояние поиска (если поиск не дал результатов)
2. Реализовать свайп-действия для каждой записи в списке
3. Интегрировать с навигацией (NavController)
4. Написать Preview для MainScreen

**Критерии готовности:**
- ✅ MainScreen создан
- ✅ Навигация работает
- ✅ Контекстное меню работает
- ✅ Preview работает

---

#### 4.5. Интеграция с RootScreen

**Задачи:**
1. Заменить заглушку eventsScreenContent() на MainScreen
2. Передать NavController в MainScreen
3. Проверить корректную работу навигации

**Критерии готовности:**
- ✅ Интеграция выполнена
- ✅ Навигация работает корректно

---

### Шаг 5: Дополнительные функции

#### 5.1. Свайпы для удаления/редактирования (опционально)

**Задачи:**
1. Реализовать SwipeToDismiss для удаления
2. Реализовать SwipeToEdit для редактирования
3. Написать тесты для свайпов

**Критерии готовности:**
- ✅ Свайпы реализованы (опционально)
- ✅ Тесты написаны

---

#### 5.2. Локализация

**Задачи:**
1. Использовать готовые строковые ресурсы из `Localization_Plan.md`:
   - Заголовок экрана: `events`
   - Пустое состояние: `what_should_we_remember`, `create_your_first_item`
   - Опции сортировки: `sort`, `sort_order`, `old_first`, `new_first`
   - Кнопки: `add_item`, `edit`, `delete`
2. Поддержка русского и английского языков (уже реализована в `Localization_Plan.md`)

**Критерии готовности:**
- ✅ Используются готовые строковые ресурсы
- ✅ Локализация работает корректно

**Примечание:** План локализации готов в документе `Localization_Plan.md`. Все строки определены и готовы к использованию.

---

### Шаг 6: Финальное тестирование

**Задачи:**
1. Проверить отображение списка записей (unit + UI тесты)
2. Проверить функциональность поиска (unit + UI тесты)
3. Проверить сортировку записей (unit + UI тесты)
4. Проверить переход к деталям записи (UI тесты)
5. Проверить отображение пустого состояния (UI тесты)
6. Проверить функциональность кнопки добавления (UI тесты)
7. Проверить контекстное меню при долгом нажатии (UI тесты)
8. Проверить обработку ошибок загрузки данных

**Критерии готовности:**
- ✅ Все тесты проходят
- ✅ Все функции работают корректно

---

## Реализация (детали)

### UI компоненты
- Использовать LazyColumn для отображения списка записей (аналог iOS List)
- Реализовать поиск в NavigationBar (searchable, placement: navigationBarDrawer, displayMode: automatic)
- Добавить кнопку сортировки с меню и Picker (Menu + Picker, как в iOS)
- Создать ListItemView для элемента списка (идентично iOS верстке):
  - HStack (Row) с spacing: 12dp
  - Цветовая метка: круглый индикатор 16x16dp (условно, если задана)
  - Название: Text с lineLimit(2), flexible width, alignment: leading
  - Количество дней: Text с multilineTextAlignment: trailing, contentTransition для анимации
  - Адаптивность: ViewThatFits или аналогичный механизм для адаптации ширины
- Реализовать свайп-действия (SwipeToDismiss или аналоги):
  - Кнопка "Удалить" (деструктивная, красная)
  - Кнопка "Редактировать"
- Обработать клики по карточкам (NavigationLink к Item Screen)
- Добавить состояние пустого экрана (EmptyState composable, идентично iOS ContentUnavailableView)
- Добавить пустое состояние поиска (если поиск не дал результатов)
- Анимация списка при изменении данных
- Подключить к ViewModel для получения данных (collectAsStateWithLifecycle)
- Использовать современные компоненты Material Design 3
- Применить тему приложения с поддержкой темного режима
- Применить корректные иконки из Material Icons

### Архитектура
- Использовать Room для локального хранения данных
- Реализовать Repository Pattern для абстракции источников данных
- Использовать Flow для реактивного обновления UI
- Применить Clean Architecture (Data → Domain → Presentation)
- Использовать Use Cases для бизнес-логики

---

## Тестирование

### Unit-тесты
- Тесты для Entity и Domain model
- Тесты для DAO (in-memory database)
- Тесты для Repository
- Тесты для Use Cases
- Тесты для ViewModel (логика поиска, сортировки, удаления)

### Интеграционные тесты
- Тесты взаимодействия Repository с Room Database
- Тесты взаимодействия ViewModel с Repository

### UI-тесты
- Проверить отображение списка записей
- Проверить функциональность поиска
- Проверить сортировку записей
- Проверить переход к деталям записи
- Проверить отображение пустого состояния
- Проверить функциональность кнопки добавления
- Проверить контекстное меню при долгом нажатии

---

## Критерии завершения этапа

Этап считается завершенным, когда:

- ✅ Все компоненты созданы и работают
- ✅ Все unit-тесты написаны и проходят
- ✅ Все интеграционные тесты написаны и проходят
- ✅ Все UI-тесты написаны и проходят
- ✅ Код соответствует правилам проекта
- ✅ Линтеры не выдают ошибок
- ✅ Поиск и сортировка работают корректно
- ✅ Навигация работает корректно

---

## Блокируемые этапы

После завершения этого экрана можно приступать к:
- Экран 3.1: Item Screen (требует навигацию из Main Screen)
- Экран 4.1: Create/Edit Item Screen (требует навигацию из Main Screen)

---

## Примечания

1. **Совместимость с iOS**: Верстка элемента списка должна быть похожа на iOS-версию для единообразия пользовательского опыта.

2. **Производительность**: Использовать LazyColumn для эффективного отображения больших списков.

3. **Реактивность**: Использовать Flow для автоматического обновления UI при изменении данных.

4. **Тестирование**: Все компоненты должны быть покрыты тестами перед использованием в других этапах.

5. **Зависимости**: ✅ Этап 7 (Модель данных) завершен и готов к использованию. ⚠️ Требуется Этап 6 (Форматирование дней).
