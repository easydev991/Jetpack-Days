# Экран 2.1: Main Screen (Главный экран)

## Статус выполнения

✅ ПОЧТИ ЗАВЕРШЕН (94%)

### Выполнено (94%)

- ✅ Исправление критических ошибок сборки (Gradle, зависимости)
- ✅ Модель данных полностью реализована (Entity, DAO, Database, Mapper, Repository)
- ✅ Функция itemsListContent() реализована со SwipeToDismissBox
- ✅ UI для поиска полностью реализован (SearchBar с фильтрацией)
- ✅ Полная интеграция навигации с DetailScreen и CreateEditScreen
- ✅ Unit-тесты для ViewModel написаны (10 тестов, все проходят)
- ✅ Интеграционные тесты для DAO, Database и Repository написаны
- ✅ Все основные компоненты работают корректно

### Осталось (6%)

- ⚠️ UI-тесты для MainScreen (не начаты)
- ⚠️ Проверка линтеров (ktlint, detekt) - опционально

**Примечание**: Этап практически завершен. Все функциональные требования реализованы и протестированы на уровне unit-тестов и интеграционных тестов. Осталось только написание UI-тестов для покрытия сценариев взаимодействия пользователя с экраном и проверка качества кода линтерами.

---

## Обзор

Main Screen является основным экраном приложения для отображения списка всех записей о событиях. Экран предоставляет функциональность поиска, сортировки и управления записями.

## Назначение

Отображение списка всех записей о событиях с возможностью поиска, сортировки и навигации к деталям записи или созданию новой записи.

## Текущее состояние

✅ **Все основные компоненты реализованы и работают корректно**:

- **Data Layer**: Entity, DAO, Database, Mapper, Repository — полностью реализованы и протестированы
- **Domain Layer**: Domain модели, Repository interface, SortOrder enum — полностью реализованы
- **Presentation Layer**: ViewModel, UI State — полностью реализованы и протестированы
- **UI Components**: MainScreen, ListItemView, SearchBar, SortMenu, Empty States — полностью реализованы
- **Тестирование**: 10 unit-тестов для ViewModel, интеграционные тесты для DAO/Database/Repository — все проходят

## Компоненты

1. **Заголовок экрана** — "События"

2. **Кнопка сортировки** (если более 1 записи)
   - Позиция: слева на Toolbar (topBarLeading)
   - Опции: "Старые первые" / "Новые первые"
   - Сортировка по дате события (timestamp)
   - Меню с DropdownMenu для выбора опции сортировки

3. **Кнопка добавления записи**
   - Позиция: справа на Toolbar (floatingActionButton)
   - Иконка: "+"
   - Открывает экран создания новой записи

4. **Список записей** (LazyColumn)
   - Карточка каждой записи содержит:
     - Название события
     - Количество дней с момента события (отформатированное)
     - Дата события
     - Цветовая метка (если задана)
   - Клик по карточке — переход к деталям записи
   - Свайп-действия:
     - Свайп влево (StartToEnd) — редактирование записи
     - Свайп вправо (EndToStart) — удаление записи

5. **Пустое состояние** (если нет записей)
   - Иконка: Material Icons (аналог "tray.fill")
   - Заголовок: "Что запомнить?"
   - Описание: "Создайте первую запись"
   - Кнопка: "Добавить запись"

6. **Пустое состояние поиска** (если поиск не дал результатов)
   - Заголовок: "Ничего не найдено"
   - Описание: "Попробуйте изменить поисковый запрос"

## Взаимодействия

- **Клик по записи** — переход к экрану деталей (Item Screen)
- **Свайп-действия**:
  - Свайп влево (StartToEnd) — открытие экрана редактирования
  - Свайп вправо (EndToStart) — удаление записи

## Навигация

- Клик на запись → Screen 3.1 (Item Screen)
- Кнопка "+" → Screen 4.1 (Create Item Screen)
- Свайп "Редактировать" → Screen 4.1 (Edit Item Screen)

## Зависимости от других этапов

- ✅ **Этап 7**: Модель данных (Entity, Domain model, Room Database, DAO, Repository) — **ЗАВЕРШЕН**, готов к использованию
- ✅ **Этап 6**: Форматирование количества дней — **РЕАЛИЗОВАНО**, используется для отображения количества дней в списке
- ✅ **Экран 1.1**: Root Screen — **ВЫПОЛНЕН**, навигация настроена через RootScreen

## Текущие проблемы

❌ Нет критических проблем - все основные компоненты реализованы и работают.

---

## Реализация

### Шаг 1: Подготовка слоя данных (Data Layer)

#### 1.1. Модель данных Room Entity

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/data/database/entity/ItemEntity.kt`

#### 1.2. Room DAO

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/data/database/dao/ItemDao.kt`

#### 1.3. Room Database

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/data/database/DaysDatabase.kt`

#### 1.4. Entity Mapper

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/data/database/mapper/ItemMapper.kt`

---

### Шаг 2: Подготовка слоя домена (Domain Layer)

#### 2.1. Domain Entity

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/domain/model/Item.kt`
- `app/src/main/java/com/dayscounter/domain/model/DisplayOption.kt`
- `app/src/main/java/com/dayscounter/domain/model/SortOrder.kt`
- `app/src/main/java/com/dayscounter/domain/model/ItemExtensions.kt`

#### 2.2. Repository Interface

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/domain/repository/ItemRepository.kt`

#### 2.3. Repository Implementation

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/data/repository/ItemRepositoryImpl.kt`

---

### Шаг 3: Подготовка слоя представления (Presentation Layer)

#### 3.1. UI State

**Статус:** ✅ ВЫПОЛНЕНО

#### 3.2. ViewModel

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/viewmodel/MainScreenViewModel.kt`
- Функционал:
  - Загрузка элементов из репозитория
  - Фильтрация по поисковому запросу (название + детали, нечувствительно к регистру)
  - Сортировка по дате (ASCENDING/DESCENDING)
  - Удаление элементов
  - Обновление элементов
  - Реактивное обновление через Flow
  - Factory-метод для создания ViewModel с DI

---

---

### Шаг 4: Реализация UI компонентов

#### 4.1. Компонент карточки записи

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/ui/component/ListItemView.kt`
- `listItemView()` composable с параметрами:
  - `item` - элемент для отображения
  - `formattedDaysText` - форматированный текст с количеством дней
  - `onClick` - обработчик клика
- Дизайн соответствует iOS-версии
- Поддержка цветовой метки (круглый индикатор 12dp)

#### 4.2. Компонент пустого состояния

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `emptyContent()` (в `MainScreen.kt`, строки 221-247) - для пустого списка
- `emptySearchContent()` (в `MainScreen.kt`, строки 252-278) - для пустых результатов поиска
- `loadingContent()` (в `MainScreen.kt`, строки 283-295) - для состояния загрузки
- `errorContent()` (в `MainScreen.kt`, строки 468-487) - для состояния ошибки

#### 4.3. Toolbar с сортировкой и кнопкой добавления

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `mainScreenTopBar()` (в `MainScreen.kt`, строки 563-620)
- `sortMenu()` (в `MainScreen.kt`, строки 166-216) - DropdownMenu для сортировки
- SearchBar (строки 567-593) с фильтрацией
- FloatingActionButton с иконкой "+" (строки 134-146)

#### 4.4. Главный экран MainScreen

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/ui/screen/MainScreen.kt`
- Основные функции:
  - `mainScreen()` - точка входа (строки 73-97)
  - `mainScreenContent()` - основной контент (строки 103-160)
  - `mainScreenContentByState()` - отображение по состоянию (строки 510-545)
  - `itemsListContent()` - список записей со свайпом (строки 300-396)

#### 4.5. Интеграция с RootScreen

**Статус:** ✅ ВЫПОЛНЕНО

**Реализовано в:**

- `app/src/main/java/com/dayscounter/ui/screen/RootScreen.kt`
- Навигация настроена через RootScreen
- Параметры навигации: `onItemClick`, `onEditClick`, `onCreateClick`

---

### Шаг 5: Дополнительные функции

#### 5.1. Свайп-действия для удаления/редактирования

**Статус:** ✅ ВЫПОЛНЕНО

#### 5.2. Локализация

**Примечание:** План локализации готов в документе `Localization_Plan.md`. Все строки определены и готовы к использованию.

---

## Реализация (детали)

### UI компоненты

- Использовать LazyColumn для отображения списка записей (аналог iOS List)
- Реализовать кнопку сортировки с меню и DropdownMenu
- Создать ListItemView для элемента списка (идентично iOS верстке):
  - Row с spacing: 12dp
  - Цветовая метка: круглый индикатор 16x16dp (условно, если задана)
  - Название: Text с lineLimit(2), flexible width
  - Количество дней: Text с multilineTextAlignment: trailing
- Реализовать свайп-действия (SwipeToDismissBox):
  - Кнопка "Удалить" (деструктивная, красная)
  - Кнопка "Редактировать" (синяя)
- Обработать клики по карточкам (NavigationLink к Item Screen)
- Добавить состояние пустого экрана (EmptyState composable, идентично iOS ContentUnavailableView)
- Добавить пустое состояние поиска (если поиск не дал результатов)
- Анимация списка при изменении данных
- Подключить к ViewModel для получения данных (collectAsState)
- Использовать современные компоненты Material Design 3
- Применить тему приложения с поддержкой темного режима
- Применить корректные иконки из Material Icons

### Архитектура

- Использовать Room для локального хранения данных
- Реализовать Repository Pattern для абстракции источников данных
- Использовать Flow для реактивного обновления UI
- Применить Clean Architecture (Data → Domain → Presentation)
- Использовать SortOrder enum для управления порядком сортировки
- Объединение Flow для комбинации фильтрации и сортировки

---

## Тестирование

### Unit-тесты

- Тесты для Entity и Domain model ✅ (реализовано в Этапе 7)
- Тесты для DAO (in-memory database) ✅ (реализовано в `app/src/androidTest/java/com/dayscounter/data/database/dao/ItemDaoTest.kt`)
- Тесты для Repository ✅ (реализовано в `app/src/androidTest/java/com/dayscounter/data/repository/ItemRepositoryIntegrationTest.kt`)
- Тесты для ViewModel ✅ (реализовано в `app/src/test/java/com/dayscounter/viewmodel/MainScreenViewModelTest.kt`)

**Детали unit-тестов для ViewModel:**

- `whenViewModelCreated_thenLoadsAllItems` - проверка загрузки элементов
- `whenSearchQueryChanged_thenFiltersItems` - проверка фильтрации по названию
- `whenSearchQueryEmpty_thenShowsAllItems` - проверка очистки поиска
- `whenSortOrderChanged_thenSortsItems` - проверка сортировки "Старые первые"
- `whenSortOrderDescending_thenShowsNewestFirst` - проверка сортировки "Новые первые"
- `whenItemDeleted_thenRemovesFromList` - проверка удаления элементов
- `whenNoItems_thenShowsEmptyState` - проверка пустого состояния
- `whenSearchInDetails_thenFindsItem` - поиск в деталях
- `whenSearchCaseInsensitive_thenFindsItem` - нечувствительность к регистру
- `whenSearchWithNoResults_thenShowsEmptyList` - пустой результат поиска

### Интеграционные тесты

- Тесты взаимодействия Repository с Room Database ✅ (`ItemRepositoryIntegrationTest.kt`)
- Тесты взаимодействия ViewModel с Repository ✅ (покрываются через MainScreenViewModelTest с FakeItemRepository)
- Тесты для DaysDatabase ✅ (`DaysDatabaseTest.kt`)

### UI-тесты

⚠️ **Статус:** Не начато

**См. раздел "Приоритет 4: Тестирование → Шаг 4.2" ниже для подробного описания задач UI-тестов.**

---

## Критерии завершения этапа

Этап считается завершенным, когда:

- ✅ Все компоненты созданы и работают
- ✅ Все unit-тесты написаны и проходят (10 тестов для ViewModel)
- ✅ Все интеграционные тесты написаны и проходят (DAO, Database, Repository)
- ✅ Код соответствует правилам проекта
- ⚠️ Линтеры (ktlint, detekt) - требуется проверка (опционально)
- ✅ Поиск и сортировка работают корректно
- ✅ Навигация работает корректно
- ⚠️ UI тесты - требуется написание (единственная оставшаяся задача)

---

## Блокируемые этапы

После завершения этого экрана можно приступать к:

- ✅ Экран 3.1: Item Screen (требует навигацию из Main Screen) — уже реализован и интегрирован
- ✅ Экран 4.1: Create/Edit Item Screen (требует навигацию из Main Screen) — уже реализован и интегрирован

**Примечание**: Экраны 3.1 и 4.1 полностью реализованы и интегрированы с Main Screen. Навигация работает корректно.

---

## Примечания

1. **Совместимость с iOS**: Верстка элемента списка соответствует iOS-версии для единообразия пользовательского опыта. ✅ **РЕАЛИЗОВАНО**

2. **Производительность**: LazyColumn используется для эффективного отображения больших списков. ✅ **РЕАЛИЗОВАНО**

3. **Реактивность**: Flow используется для автоматического обновления UI при изменении данных. ✅ **РЕАЛИЗОВАНО**

4. **Тестирование**: Все компоненты покрыты тестами (unit + интеграционные). ✅ **ВЫПОЛНЕНО**

5. **Зависимости**: ✅ Этап 7 (Модель данных) завершен и готов к использованию. ✅ Этап 6 (Форматирование дней) реализован и используется.

6. **Поиск**: Фильтрация реализована на уровне ViewModel через объединение Flow. Фильтрация выполняется по названию и описанию с игнорированием регистра. ✅ **РЕАЛИЗОВАНО** - UI для поиска реализован.

7. **Сортировка**: Реализована через enum SortOrder и выбор порядка в Repository и DAO. По умолчанию — новые первые (DESCENDING). ✅ **РЕАЛИЗОВАНО** - UI для сортировки реализован и полностью интегрирован.

8. **Свайп-действия**: SwipeToDismissBox реализован с функцией itemsListContent(). ✅ **РЕАЛИЗОВАНО** - свайп-действия для удаления и редактирования работают корректно.

9. **Иконки**: Зависимость `implementation("androidx.compose.material:material-icons-extended:1.7.6")` добавлена для доступа к иконке "tray.fill" для пустого состояния. ✅ **ДОБАВЛЕНО**.

10. **Ошибки сборки**: Версия Gradle обновлена для обеспечения совместимости. ✅ **ИСПРАВЛЕНО**.

11. **Навигация**: Полная интеграция с DetailScreen и CreateEditScreen работает корректно. ✅ **ВЫПОЛНЕНО**

---

## Обновленный план завершения Main Screen

### Приоритет 1: ✅ ВЫПОЛНЕНО - Исправление критических ошибок сборки

#### Шаг 1.1: ✅ ВЫПОЛНЕНО - Исправление версии Gradle

#### Шаг 1.2: ✅ ВЫПОЛНЕНО - Добавление зависимости material-icons-extended

#### Шаг 1.3: ✅ ВЫПОЛНЕНО - Реализация отсутствующей функции itemsListContent()

### Приоритет 2: ✅ ВЫПОЛНЕНО - Реализация функциональности поиска

#### Шаг 2.1: ✅ ВЫПОЛНЕНО - Добавление UI для поиска

### Приоритет 3: ✅ ВЫПОЛНЕНО - Полная интеграция навигации

#### Шаг 3.1: ✅ ВЫПОЛНЕНО - Интеграция с DetailScreen

#### Шаг 3.2: ✅ ВЫПОЛНЕНО - Интеграция с CreateEditScreen (создание)

#### Шаг 3.3: ✅ ВЫПОЛНЕНО - Интеграция с CreateEditScreen (редактирование)

### Приоритет 4: Тестирование

#### Шаг 4.1: ✅ ВЫПОЛНЕНО - Написание unit-тестов для ViewModel

**Что было сделано:**

- Создан файл `MainScreenViewModelTest.kt` с 10 тестами
- Все тесты используют FakeItemRepository для изоляции
- Тесты покрывают основные сценарии:
  - Загрузка записей при создании ViewModel
  - Фильтрация по поисковому запросу
  - Сортировка записей (возрастание/убывание)
  - Удаление записей
  - Отображение пустого состояния
  - Поиск в деталях (нечувствительный к регистру)
  - Пустой результат поиска
- Все тесты проходят успешно

#### Шаг 4.2: Написание UI-тестов (единственная оставшаяся задача)

**Статус:** ❌ НЕ ВЫПОЛНЕНО

**Описание:**

Это единственная оставшаяся задача для завершения этапа Main Screen. Все остальные компоненты реализованы, протестированы на уровне unit-тестов и работают корректно.

**Задачи:**

Создать файл `app/src/androidTest/java/com/dayscounter/ui/screen/MainScreenTest.kt` и написать тесты для следующих сценариев:

1. **Проверить отображение списка записей**
   - Убедиться, что элементы списка отображаются корректно
   - Проверить отображение количества дней
   - Проверить отображение цвета записи (если задан)

2. **Проверить функциональность поиска**
   - Открыть SearchBar
   - Ввести поисковый запрос
   - Проверить, что список фильтруется
   - Проверить пустое состояние при отсутствии результатов

3. **Проверить сортировку записей**
   - Нажать на кнопку сортировки
   - Выбрать опцию "Старые первые"
   - Проверить, что порядок изменился
   - Выбрать опцию "Новые первые"
   - Проверить, что порядок изменился обратно

4. **Проверить переход к деталям записи**
   - Кликнуть на карточку записи
   - Убедиться, что открывается DetailScreen
   - Проверить, что itemId корректно передается

5. **Проверить отображение пустого состояния**
   - Убедиться, что при отсутствии записей отображается emptyContent()
   - Проверить отображение иконки, заголовка и описания

6. **Проверить функциональность кнопки добавления**
   - Нажать на FAB (+)
   - Убедиться, что открывается CreateEditScreen в режиме создания

7. **Проверить свайп-действия**
   - Свайп записи влево → проверить открытие редактирования
   - Свайп записи вправо → проверить удаление записи
   - Проверить, что удаленная запись исчезает из списка

**Технические требования:**

- Использовать Compose Testing API (ComposeTestRule)
- Использовать Espresso для проверки навигации
- Тесты должны быть независимы друг от друга
- Использовать readable test names (согласно JUnit 5)

**Пример структуры тестового файла:**

```kotlin
@HiltAndroidTest
class MainScreenTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    @Inject
    lateinit var repository: ItemRepository

    @Before
    fun setup() {
        // Инициализация зависимостей
        HiltAndroidRule(this).inject()
    }

    @Test
    fun whenItemsExist_thenDisplaysList() {
        // Given - подготовка данных
        // When - выполнение действий
        // Then - проверка результатов
    }

    // ... остальные тесты
}
```

**Критерий готовности:**

- ✅ Все UI-тесты написаны
- ✅ Все UI-тесты проходят успешно
- ✅ Покрытие сценариев взаимодействия пользователя составляет минимум 70%

**Инструменты:**

- Compose Testing API
- Espresso (для навигации)
- Hilt (для DI в тестах)
- JUnit 5

**Примечания:**

1. UI-тесты должны использовать реальные или фейковые реализации компонентов
2. Тесты должны быть быстрыми и стабильными
3. Использовать `@ExperimentalCoroutinesApi` для корутин в тестах
4. Для тестирования свайпов можно использовать `performTouchInput` из Compose Testing

### Приоритет 5: Проверка качества кода (опционально)

#### Шаг 5.1: Запуск линтеров

**Статус:** Ожидает выполнения

**Задачи:**

1. Запустить `./gradlew ktlintCheck`
2. Запустить `./gradlew detekt`
3. Исправить все найденные ошибки

**Критерий готовности:** ktlint и detekt не выдают ошибок

---
