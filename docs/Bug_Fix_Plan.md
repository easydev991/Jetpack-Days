# План исправления багов после внедрения DI через Factory Methods

**Дата создания:** 2025-01-02  
**Статус:** НАЧАЛО РАБОТЫ

---

## Обзор проблем

После внедрения factory методов для CreateEditScreenViewModel и DetailScreenViewModel обнаружены следующие проблемы, требующие исправления:

1. ❌ **Баг #1**: DetailScreen не обновляется после редактирования
2. ✅ **Баг #2**: Toolbar перекрывает контент списка (ИСПРАВЛЕН)
3. ❌ **Баг #3**: Удаление записей работает некорректно
4. ❌ **Баг #4**: Поиск не работает
5. ❌ **Баг #5**: Пропадание записей при поиске
6. ✅ **Баг #6**: Неправильная верстка ListItemView (ИСПРАВЛЕН)
7. ✅ **Баг #7**: Нижняя навигация не видна (ИСПРАВЛЕН)
8. ✅ **Баг #8**: Контент заезжает под камеру (ИСПРАВЛЕН)
9. ❌ **Баг #9**: Изменение displayOption не обновляет UI
10. ❌ **Баг #10**: Отсутствуют Composable Preview
11. ❌ **Баг #11**: Свайп слева направо открывает несколько экранов редактирования

---

## Приоритеты исправления

| Баг | Приоритет | Влияние | Сложность | Оценка |
|------|------------|-----------|----------|----------|---------|
| #1   | Высокий    | Высокое   | Средняя   | 2-3 ч   |
| #2   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #3   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #4   | Высокий    | Высокое   | Средняя    | 2-3 ч    |
| #5   | Высокий    | Высокое   | Средняя    | 2-4 ч    |
| #6   | Средний    | Среднее   | Низкая    | 1 ч       |
| #7   | Средний    | Среднее   | Низкая    | 1 ч       |
| #8   | Средний    | Среднее   | Низкая    | 1-2 ч     |
| #9   | Низкий     | Низкое    | Низкая    | 1-2 ч     |
| #10  | Низкий     | Низкое    | Низкая    | 1 ч        |
| #11  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #12  | Высокий    | Высокое   | Средняя   | 2-3 ч     |

---

## Баг #1: DetailScreen не обновляется после редактирования

### Описание

**Текущее поведение (правильная навигация, но проблема с данными):**
- DetailScreen → CreateEditScreen (редактирование) → сохранение → возвращаемся на DetailScreen
- **ПРОБЛЕМА:** На DetailScreen отображаются старые данные, хотя запись в базе данных уже обновлена
- Если вернуться на MainScreen и снова зайти на DetailScreen, тогда обновленные данные отображаются

**Ожидаемое поведение:**
- DetailScreen → CreateEditScreen (редактирование) → сохранение → возвращаемся на DetailScreen с актуальными данными
- DetailScreen должен показывать обновленные данные сразу после сохранения

### Причина

Проблема не в навигации (она работает правильно), а в механизме обновления данных в DetailScreen:

1. **DetailScreenViewModel кэшируется и переиспользуется:**
   - При навигации DetailScreen → CreateEditScreen → DetailScreen, ViewModel может не пересоздаваться
   - ViewModel использует одну и ту же фабрику, поэтому Compose Navigation переиспользует существующий экземпляр
   - Данные загружаются при инициализации и не обновляются

2. **DetailScreen загружает данные однократно:**
   - При инициализации ViewModel загружает данные из репозитория и сохраняет в StateFlow
   - При возврате на DetailScreen не происходит перезагрузки данных
   - Отсутствует реактивная подписка на изменения конкретной записи

3. **Отсутствует реактивное обновление:**
   - DetailScreenViewModel не подписан на изменения в репозитории для конкретной записи
   - При редактировании записи в CreateEditScreen DetailScreen не получает уведомление об изменениях
   - StateFlow в DetailScreenViewModel не обновляется при изменениях в базе данных

### Шаги исправления

#### Шаг 1.1: Анализ текущей реализации DetailScreenViewModel

**Задача:** Понять, как загружаются данные в DetailScreen

**Действия:**
1. Изучить `DetailScreenViewModel.kt`:
   - Проверить, как загружается данные (однократно или через Flow)
   - Проверить, какие методы использует репозиторий (синхронные или Flow)
   - Проверить, где и как хранятся данные в ViewModel
2. Изучить `ItemRepository`:
   - Проверить наличие метода `getItemFlow(itemId: Long): Flow<Item>`
   - Проверить текущие методы для получения одной записи
3. Проверить навигацию в `RootScreenComponents.kt`:
   - Убедиться, что DetailScreen использует правильную фабрику для ViewModel
   - Проверить, что itemId корректно передается через SavedStateHandle

#### Шаг 1.2: Реализация реактивного обновления в DetailScreenViewModel

**Задача:** Обеспечить автоматическое обновление данных при изменениях в репозитории

**Решение (предпочтительное):** Подписка на Flow для конкретной записи

**Действия:**

1. **В ItemRepository добавить Flow метод (если нет):**
```kotlin
// В ItemRepository.kt
fun getItemFlow(itemId: Long): Flow<Item> {
    return itemDao.getItemByIdFlow(itemId)
}
```

2. **В DetailScreenViewModel использовать Flow вместо однократной загрузки:**

Текущая (проблемная) реализация (пример):
```kotlin
private val _uiState = MutableStateFlow<UiState>(UiState.Loading)
val uiState: StateFlow<UiState> = _uiState.asStateFlow()

init {
    loadItem(itemId)
}

private fun loadItem(itemId: Long) {
    viewModelScope.launch {
        val item = repository.getItemById(itemId) // Однократная загрузка
        _uiState.value = UiState.Success(item)
    }
}
```

Требуемая (правильная) реализация:
```kotlin
val uiState: StateFlow<UiState> = itemFlow.map { item ->
    UiState.Success(item)
}.stateIn(
    scope = viewModelScope,
    started = SharingStarted.WhileSubscribed(5000),
    initialValue = UiState.Loading
)

private val itemFlow = savedStateHandle.get<Long>("itemId")?.let { itemId ->
    repository.getItemFlow(itemId)
} ?: flowOf(null)
```

3. **Проверить DetailScreen.kt:**
   - Убедиться, что UI подписан на `viewModel.uiState.collectAsState()`
   - При изменении itemId должен происходить автоматический перезапуск Flow через `LaunchedEffect(itemId)`

#### Шаг 1.3: Проверка кэширования ViewModel

**Задача:** Убедиться, что ViewModel не создает проблем при навигации

**Действия:**
1. Проверить фабрику DetailScreenViewModel в `RootScreenComponents.kt`:
   - Убедиться, что фабрика создает ViewModel корректно
   - При навигации на DetailScreen с тем же itemId может переиспользоваться существующий экземпляр
2. Если ViewModel кэшируется и это вызывает проблемы:
   - Рассмотреть использование уникального ключа для навигации
   - Или добавить механизм для принудительного обновления данных при появлении экрана
3. Добавить `LaunchedEffect(itemId)` в DetailScreen.kt:
   - Это обеспечит перезапуск подписки при изменении itemId
   - Или может быть использовано для принудительной перезагрузки данных

#### Шаг 1.4: Тестирование сценария

**Задача:** Проверить, что данные обновляются корректно

**Тестовый сценарий:**
1. Открыть запись на DetailScreen
2. Нажать "Редактировать"
3. Изменить данные (например, название)
4. Нажать "Сохранить"
5. Вернуться на DetailScreen
6. Проверить, что данные обновлены

**Проверки:**
- ✅ DetailScreen показывает обновленные данные сразу после сохранения
- ✅ MainScreen также показывает обновленные данные в списке
- ✅ При повторном входе на DetailScreen данные остаются актуальными
- ✅ Изменения корректно сохранены в базе данных

**Критерий готовности:**
- ✅ DetailScreen показывает обновленные данные сразу после возврата из CreateEditScreen
- ✅ Автоматическое обновление через Flow работает
- ✅ MainScreen синхронизируется с изменениями
- ✅ Проблема кэширования ViewModel решена

---

## Баг #2: Toolbar перекрывает контент списка ✅ **ИСПРАВЛЕН**

### Описание

Список записей на главном экране перекрывается верхним тулбаром.

### Причина

Проблема в верстке Scaffold: TopAppBar перекрывает контент, LazyColumn не использует `paddingValues`.

### Шаги исправления

#### Шаг 2.1: Анализ верстки MainScreen ✅ **ВЫПОЛНЕН**

**Задача:** Понять структуру верстки

**Действия:**
1. ✅ Изучить текущую верстку MainScreen.kt
2. ✅ Проверить использование Scaffold и TopAppBar
3. ✅ Сравнить с RootScreen (где навигация)

**Результат:** Проблема обнаружена в функции `itemsListContent` - LazyColumn не использует `paddingValues` от Scaffold

#### Шаг 2.2: Исправление верстки ✅ **ВЫПОЛНЕН**

**Задача:** Обеспечить правильное расположение контента

**Действия:**
1. ✅ Добавить параметр `paddingValues` в `itemsListContent`, `emptyContent` и `emptySearchContent`
2. ✅ Применить `contentPadding = paddingValues` к `LazyColumn`
3. ✅ Применить `paddingValues` в функциях с пустым контентом

**Критерий готовности:**
- ✅ Список записей отображается полностью (не перекрывается AppBar)
- ✅ При скролле список не заезжает под AppBar
- ✅ AppBar не перекрывает контент списка
- ✅ Все тесты проходят успешно
- ✅ Сборка приложения проходит успешно

### Дата исправления: 2025-01-02

---

## Баг #3: Удаление записей работает некорректно

### Описание

**Текущее поведение:**
- Удаление записей работает только на главном экране через свайп
- При удалении нет диалогового окна для подтверждения удаления
- Запись пропадает мгновенно с резким рывком без анимации

**Требуемое поведение:**
- Удаление записей должно работать через свайп на главном экране
- При попытке удаления должно отображаться диалоговое окно для подтверждения или отмены удаления
- При подтверждении запись должна плавно исчезать с анимацией, а не мгновенно пропадать
- После удаления пользователь должен быть на главном экране

### Причина

1. **Отсутствует диалог подтверждения удаления:**
   - SwipeToDismiss сразу удаляет запись без запроса подтверждения
   - Нет UI для AlertDialog с кнопками "Отмена" и "Удалить"
   - Нет проверки подтверждения перед удалением

2. **Отсутствует анимация удаления:**
   - SwipeToDismiss не настроен на плавную анимацию удаления
   - Запись пропадает мгновенно с резким рывком
   - Не используется стандартная анимация удаления в LazyColumn

3. **Навигация может не работать корректно:**
   - После удаления не обеспечивается нахождение пользователя на главном экране
   - Нет обработки результата удаления

### Шаги исправления

#### Шаг 3.1: Анализ текущей реализации удаления

**Задача:** Понять, как сейчас работает удаление

**Действия:**
1. Изучить `MainScreen.kt`:
   - Найти SwipeToDismiss для элементов списка
   - Проверить, как обрабатывается свайп для удаления
   - Проверить, есть ли какие-то анимации
2. Изучить `ListItemView.kt` или компонент для отображения элементов:
   - Проверить, используется ли SwipeToDismiss или отдельный компонент
   - Проверить, где определяется действие удаления
3. Изучить `MainScreenViewModel.kt`:
   - Проверить метод `deleteItem(item)`
   - Проверить, как выполняется удаление в репозитории

#### Шаг 3.2: Добавление диалога подтверждения удаления

**Задача:** Реализовать диалог подтверждения перед удалением

**Действия:**
1. Добавить состояние для отслеживания диалога в MainScreenViewModel (если нет):
```kotlin
private val _showDeleteDialog = MutableStateFlow<Item?>(null)
val showDeleteDialog: StateFlow<Item?> = _showDeleteDialog.asStateFlow()
```

2. Добавить методы для управления диалогом в ViewModel:
```kotlin
fun requestDelete(item: Item) {
    _showDeleteDialog.value = item
}

fun confirmDelete() {
    _showDeleteDialog.value?.let { item ->
        deleteItem(item)
    }
    _showDeleteDialog.value = null
}

fun cancelDelete() {
    _showDeleteDialog.value = null
}
```

3. В MainScreen.kt добавить AlertDialog для подтверждения удаления:
   - Показывать диалог когда `viewModel.showDeleteDialog.collectAsState()` не null
   - Добавить кнопки "Отмена" (вызывает `viewModel.cancelDelete()`)
   - Добавить кнопку "Удалить" (вызывает `viewModel.confirmDelete()`)
   - Показывать название удаляемой записи в диалоге

4. Изменить обработчик свайпа для удаления:
   - Вместо прямого вызова `viewModel.deleteItem(item)` вызвать `viewModel.requestDelete(item)`

#### Шаг 3.3: Добавление анимации удаления

**Задача:** Обеспечить плавную анимацию удаления

**Действия:**
1. Изучить текущий SwipeToDismiss:
   - Проверить параметры анимации
   - Проверить, используется ли `DismissValue` и `DismissDirection`

2. Настроить SwipeToDismiss с плавной анимацией:
   - Добавить `animateTo` параметр для плавного завершения анимации
   - Использовать `confirmValueChange` для контроля начала удаления
   - Добавить отложенное удаление после завершения анимации

3. Рассмотреть использование стандартных анимаций Compose:
   - Добавить `AnimatedVisibility` для плавного исчезновения записи
   - Или использовать `ScaleTransition` / `FadeTransition` для эффекта удаления
   - Комбинировать с SwipeToDismiss для плавного эффекта

4. Проверить LazyColumn и LazyItemScope:
   - Использовать `animateItemPlacement()` для плавного перестроения списка
   - Проверить, что не перескакивает список при удалении элемента

#### Шаг 3.4: Обновление состояния удаления

**Задача:** Обеспечить корректную навигацию после удаления

**Действия:**
1. Проверить, что после удаления пользователь остается на главном экране
2. Убедиться, что нет лишних переходов при удалении
3. Проверить, что удаленная запись исчезает из списка с анимацией
4. Проверить, что список корректно перестраивается после удаления

**Критерий готовности:**
- ✅ При свайпе элемента для удаления отображается диалог подтверждения
- ✅ Диалог показывает название удаляемой записи
- ✅ При отмене диалога запись остается в списке, ничего не удаляется
- ✅ При подтверждении запись удаляется
- ✅ Запись исчезает плавно с анимацией, не резким рывком
- ✅ Анимация выглядит естественно и плавно
- ✅ После удаления пользователь остается на главном экране
- ✅ Список корректно перестраивается без скачков
- ✅ Удаленная запись полностью исчезает из списка

---

## Баг #4: Поиск не работает

### Описание

Если вводить в поиск названия ранее созданных записей, то ничего не происходит:
- Ничего не происходит при нажатии на кнопку поиска на клавиатуре
- Ничего не происходит при нажатии на enter на клавиатуре

### Причина

Проблема в SearchBar:
- SearchBar может быть в режиме "expanded" / "active"
- Поисковый запрос не отправляется в ViewModel при нажатии Enter
- Отсутствует явная обработка события подтверждения поиска

### Шаги исправления

#### Шаг 4.1: Анализ SearchBar

**Задача:** Понять поведение SearchBar

**Действия:**
1. Изучить текущую реализацию SearchBar в MainScreen.kt
2. Проверить параметры SearchBar
3. Проверить обработку `onQueryChange`
4. Проверить обработку `onSearch`

#### Шаг 4.2: Исправление обработки поиска

**Задача:** Обеспечить работу поиска

**Действия:**
1. Добавить обработку `onActiveChange` для отслеживания состояния фокуса
2. При потере фокуса искать выполнить поиск
3. Добавить явную обработку нажатия Enter
4. Убедиться, что фильтрация работает для всех записей

**Критерий готовности:**
- ✅ Поиск работает при вводе текста
- ✅ Поиск выполняется при нажатии на Enter
- ✅ Поиск работает для всех записей, включая только что созданные
- ✅ Результаты поиска отображаются корректно

---

## Баг #5: Пропадание записей при поиске

### Описание

**Проблема 1 (пропадание записей):**
Иногда при переходе в режим поиска и обратно, или при нажатии на плюс для создания новой записи внезапно пропадают почти все записи с главного экрана кроме одной, а потом могут появиться при очередном появлении главного экрана - например, если нажать на иконку поиска, ввести что-то, а потом нажать на кнопку с плюсом, и потом вернуться назад - большинство записей не будет видно - они как будто скрыаются вертикально наверх.

**Проблема 2 (кнопка создания видна при поиске):**
Кнопка с плюсом (которая открывает экран создания записи) остается видимой при переходе в режим поиска, что может привести к путанице и конфликтам состояний.

**Требование:**
При переходе в режим поиска кнопку с плюсом нужно скрывать, чтобы избежать смешивания состояний "поиска" и "создания записи". Кнопка должна быть видна только когда поиск не активен.

### Причина

Проблема в управлении состоянием Flow и UI:

1. **Конфликт состояний при поиске:**
   - При активном поиске фильтрация может конфликтовать с другим состоянием
   - При создании новой записи при активном поиске происходит сброс состояния
   - Отсутствует правильное сохранение состояния при навигации между экранами

2. **Кнопка создания не учитывает состояние поиска:**
   - Кнопка с плюсом всегда видима на MainScreen
   - Нет проверки на активный режим поиска
   - Пользователь может нажать плюс при активном поиске, что вызывает путаницу

### Шаги исправления

#### Шаг 5.1: Анализ потока данных

**Задача:** Понять причину пропадания записей и проверить состояние кнопки

**Действия:**
1. Изучить `MainScreenViewModel.observeItems()`
2. Проверить логику фильтрации
3. Проверить состояние `searchQuery` при навигации
4. Проверить сохранение состояния при создании новой записи
5. Изучить верстку MainScreen.kt и найти кнопку с плюсом
6. Проверить, есть ли состояние для активного режима поиска в ViewModel

#### Шаг 5.2: Исправление управления состоянием

**Задача 1:** Сохранять состояние поиска правильно

**Действия:**
1. Сохранять состояние поиска при навигации на DetailScreen
2. Сохранять состояние поиска при навигации на CreateEditScreen
3. Восстанавливать состояние при возврате на MainScreen
4. Убедиться, что состояние не сбрасывается неожиданно

**Задача 2:** Скрыть кнопку создания при активном поиске

**Действия:**
1. Добавить состояние для отслеживания активного режима поиска в MainScreenViewModel (если нет)
2. Передать это состояние в UI MainScreen
3. В верстке MainScreen.kt добавить условие видимости для кнопки с плюсом:
   - Показывать кнопку только когда `!isSearchActive`
   - Или использовать флаг/переменную для управления видимостью
4. Проверить, что при выходе из режима поиска кнопка снова становится видимой
5. Убедиться, что скрытие кнопки не ломает навигацию и UX

**Критерий готовности:**
- ✅ При переходе к поиску записи не пропадают
- ✅ При создании новой записи состояние поиска сохраняется
- ✅ При возврате на главный экран состояние восстанавливается
- ✅ Записи отображаются корректно в любой момент
- ✅ Кнопка с плюсом скрывается при активном режиме поиска
- ✅ Кнопка с плюсом отображается когда поиск не активен
- ✅ Нет конфликтов между режимом поиска и созданием записи

---

## Баг #6: Неправильная верстка ListItemView ✅ **ВЫПОЛНЕН**

### Описание

В UI-компоненте для записи на главном экране неправильно расположены тексты:
- Текст с количеством дней должен быть справа и занимать не больше 30% от ширины экрана
- Слева должен быть вертикальный стек с названием записи и внизу с описанием
- Для названия и для описания должен быть лимит в 2 строки для главного экрана
- На детальном экране лимит не нужен

### Причина

Проблема в верстке ListItemView: отсутствие ограничения ширины, тексты могут быть слишком длинными, нет ограничений на количество строк.

### Шаги исправления

#### Шаг 6.1: Анализ текущей верстки ✅ **ВЫПОЛНЕН**

**Задача:** Понять текущую верстку

**Действия:**
1. ✅ Изучить текущую верстку ListItemView.kt
2. ✅ Проверить использование Modifier.weight()
3. ✅ Проверить отступы и выравнивание

#### Шаг 6.2: Исправление верстки ✅ **ВЫПОЛНЕН**

**Задача:** Реализовать правильную верстку

**Действия:**
1. ✅ Разделить контент на две части с использованием `Modifier.weight()`
2. ✅ Левая часть (70% ширины): Column с названием и описанием
3. ✅ Правая часть (30% ширины): текст с количеством дней, выровненный по правому краю
4. ✅ Добавить `maxLines = 2` и `TextOverflow.Ellipsis` для названия и описания

**Критерий готовности:**
- ✅ Текст с количеством дней занимает не более 30% ширины
- ✅ Название ограничено до 2 строк на главном экране
- ✅ Описание ограничено до 2 строк на главном экране
- ✅ На DetailScreen тексты не ограничены по длине
- ✅ Длинный текст обрезается с многоточием

### Дата исправления: 2025-01-02

---

## Баг #7: Нижняя навигация не видна

### Описание

Нижняя панель навигации всегда не видна (там должно быть две кнопки "список" и "ещё").

### Причина

Проблема в RootScreen: NavigationBar реализована, но используется `Column` вместо `Scaffold`, что не позволяет NavigationBar занимать своё место в верстке.

### Шаги исправления

#### Шаг 7.1: Анализ навигации ✅ **ВЫПОЛНЕН**

**Задача:** Понять проблему с навигацией

**Действия:**
1. ✅ Изучить `navigationBarContent()` в RootScreenComponents.kt
2. ✅ Проверить условие видимости NavigationBar
3. ✅ Проверить структуру экранов и вкладок

**Результат:** Проблема обнаружена в `rootScreenContent()` - используется `Column` вместо `Scaffold`

#### Шаг 7.2: Исправление навигации ✅ **ВЫПОЛНЕН**

**Задача:** Обеспечить отображение навигации

**Действия:**
1. ✅ Заменить `Column` на `Scaffold` в `rootScreenContent()`
2. ✅ Переместить `NavigationBar` в параметр `bottomBar` Scaffold
3. ✅ Добавить передачу `paddingValues` из Scaffold в `navHostContent()`
4. ✅ Применить `paddingValues` к `NavHost` через Modifier.padding()
5. ✅ Добавить `contentWindowInsets = WindowInsets(0, 0, 0, 0)` для отключения автоматических отступов StatusBar

**Критерий готовности:**
- ✅ На MainScreen видна NavigationBar с двумя вкладками
- ✅ На DetailScreen и CreateEditScreen NavigationBar скрыта
- ✅ При переключении вкладок работает корректно
- ✅ Нет лишнего пространства над заголовком экрана

### Дата исправления: 2025-01-02

---

## Баг #8: Контент заезжает под камеру ✅ **ИСПРАВЛЕН**

### Описание

При повороте экрана контент заезжал под переднюю камеру.

### Причина

Использовался `Column` вместо `Scaffold` в RootScreen - отсутствовали безопасные зоны для системных баров.

### Шаги исправления ✅ **ВЫПОЛНЕН**

**Задача:** Обеспечить безопасное отображение контента

**Действия:**
1. ✅ Заменить `Column` на `Scaffold` в RootScreen (выполнено в баге #7)
2. ✅ Передать `paddingValues` из Scaffold в `navHostContent()`
3. ✅ Применить `paddingValues` к NavHost через Modifier.padding()

**Критерий готовности:**
- ✅ Контент не заезжает под камеру
- ✅ При повороте экрана контент отображается корректно

### Дата исправления: 2025-01-02

---

## Баг #9: Изменение displayOption не обновляет UI

### Описание

**Проблема 1 (на CreateEditScreen):**
На экране создания/изменения записи можно выбирать display format, но его изменение не приводит к обновлению preview на этом же экране - форматирование дней остается прежним, хотя выбран другой displayOption.

**Проблема 2 (на MainScreen):**
После сохранения записи с измененным displayOption, форматирование на главном экране также остается прежним - MainScreen не пересчитывает форматирование при изменении displayOption.

**Требование:**
- При изменении displayOption на экране CreateEditScreen должен сразу обновляться preview с новым форматированием
- При сохранении записи с измененным displayOption, форматирование на MainScreen должно обновляться
- Изменения displayOption должны отражаться во всех компонентах, которые показывают форматирование дней

### Причина

Проблема в реактивном обновлении на разных экранах:

1. **На CreateEditScreen:**
   - DisplayOption хранится в состоянии ViewModel, но UI не реагирует на изменения этого поля
   - Preview на CreateEditScreen использует кэшированное значение или не подписан на изменения displayOption
   - Возможно, форматирование выполняется один раз при инициализации и не обновляется

2. **На MainScreen:**
   - DisplayOption сохраняется в записи в базе данных, но MainScreen не пересчитывает форматирование
   - ListItemView может использовать устаревшее форматирование
   - Отсутствует реактивная связь между displayOption в Item и форматированием

### Шаги исправления

#### Шаг 9.1: Анализ потока данных на CreateEditScreen

**Задача:** Понять, почему displayOption не обновляет preview на CreateEditScreen

**Действия:**
1. Изучить `CreateEditScreenViewModel.kt`:
   - Проверить, где хранится displayOption (в состоянии ViewModel)
   - Проверить, есть ли StateFlow для displayOption
   - Проверить, как displayOption используется для форматирования в preview
2. Изучить `CreateEditScreen.kt`:
   - Проверить, как UI подписан на изменения displayOption
   - Проверить, как форматируется preview (однократно или реактивно)
   - Проверить, используется ли `collectAsState()` для displayOption
3. Проверить, есть ли вызов метода форматирования при изменении displayOption

#### Шаг 9.2: Анализ потока данных на MainScreen

**Задача:** Понять, почему displayOption не обновляет форматирование на MainScreen

**Действия:**
1. Изучить `MainScreenViewModel` и форматирование дней:
   - Проверить, как displayOption используется из Item
   - Проверить, где происходит форматирование (в ViewModel или в UI)
2. Проверить `ListItemView.kt`:
   - Проверить, как displayOption используется для форматирования
   - Проверить, откуда берется displayOption для каждой записи
   - Проверить, что форматирование выполняется при каждом изменении Item
3. Проверить Item сущность:
   - Убедиться, что displayOption корректно сохраняется в базе данных
   - Проверить, что при загрузке из базы displayOption не теряется

#### Шаг 9.3: Исправление форматирования на CreateEditScreen

**Задача:** Обеспечить реактивное обновление preview при изменении displayOption

**Действия:**
1. Убедиться, что CreateEditScreenViewModel использует StateFlow для displayOption:
```kotlin
// В CreateEditScreenViewModel
val displayOption: StateFlow<DisplayOption> = _displayOption.asStateFlow()
private val _displayOption = MutableStateFlow<InitialValue)
```

2. Проверить, что CreateEditScreen подписан на изменения displayOption:
```kotlin
// В CreateEditScreen
val displayOption by viewModel.displayOption.collectAsState()
// Использовать displayOption для форматирования preview
```

3. Убедиться, что при каждом изменении displayOption происходит пересчет форматирования в preview
4. Проверить, что компонент preview перерисовывается при изменении displayOption

#### Шаг 9.4: Исправление форматирования на MainScreen

**Задача:** Обеспечить корректное форматирование при изменении displayOption

**Действия:**
1. Убедиться, что displayOption сохраняется корректно при создании/редактировании записи
2. Проверить, что при загрузке Item из базы данных displayOption присутствует
3. Убедиться, что MainScreen использует Flow для получения списка записей (для автоматического обновления)
4. Проверить, что ListItemView использует displayOption из Item для форматирования
5. Убедиться, что при изменении Item в базе данных (включая displayOption) список перерисовывается с новым форматированием

#### Шаг 9.5: Проверка сохранения и загрузки displayOption

**Задача:** Убедиться, что displayOption корректно сохраняется и загружается

**Действия:**
1. Проверить Item сущность:
   - Убедиться, что displayOption поле корректно определено
   - Проверить, что displayOption включено в Room таблицу
2. Проверить ItemDao:
   - Убедиться, что при сохранении записи displayOption сохраняется
   - Проверить, что при загрузке записи displayOption загружается
3. Проверить ItemRepository:
   - Убедиться, что displayOption не теряется при передаче данных

**Критерий готовности:**
- ✅ При изменении displayOption на CreateEditScreen preview обновляется немедленно
- ✅ Форматирование дней на CreateEditScreen соответствует выбранному displayOption
- ✅ При сохранении записи displayOption корректно сохраняется в базе данных
- ✅ При загрузке записи из базы displayOption присутствует и корректен
- ✅ При изменении displayOption форматирование на MainScreen обновляется автоматически
- ✅ Изменения displayOption отражаются во всех компонентах (CreateEditScreen preview, MainScreen список)
- ✅ Форматирование дней соответствует выбранному displayOption везде

---

## Баг #10: Отсутствуют Composable Preview

### Описание

Для всех UI-компонентов и для любой верстки нужно добавить Composable-Preview для проверки верстки без запуска эмулятора по аналогии с файлом ListItemView.kt.

### Причина

Отсутствие Preview делает сложным тестирование верстки

### Шаги исправления

#### Шаг 10.1: Определение компонентов без Preview

**Задача:** Найти все компоненты без Preview

**Действия:**
1. Поискать все Composable функции
2. Проверить наличие `@Preview` аннотаций
3. Составить список компонентов без Preview

#### Шаг 10.2: Добавление Preview для компонентов

**Задача:** Добавить Preview для всех компонентов

**Действия:**
1. Добавить `@Preview` для всех Composable в ListItemView.kt
2. Добавить `@Preview` для всех Composable в MainScreen.kt
3. Добавить `@Preview` для всех Composable в DetailScreen.kt
4. Добавить `@Preview` для всех Composable в CreateEditScreen.kt
5. Добавить `@Preview` для всех Composable в RootScreenComponents.kt

**Критерий готовности:**
- ✅ Все Composable функции имеют Preview
- ✅ Preview работает для проверки верстки
- ✅ Можно проверить верстку без запуска эмулятора

---

## Баг #11: Свайп слева направо открывает несколько экранов редактирования

### Описание

**Текущее поведение (проблемное):**
- На главном экране можно сделать свайп по записи слева направо
- При свайпе слева направо открываются несколько экранов редактирования подряд
- Все эти экраны имеют заголовок "New Item"
- На видимом экране можно сохранить изменения
- После сохранения автоматически возвращаемся на лишний экран с тем же заголовком "New Item"
- Потом можно еще несколько раз вернуться назад до главного экрана
- На главном экране навсегда зависает иконка редактирования на той записи, которую редактировали
- Иконка редактирования выглядит так, будто мы тянули до конца слева направо и это выделение не вернулось назад при отпускании пальца

**Ожидаемое поведение:**
- Свайп по записи слева направо должен открывать экран редактирования (один экран)
- Экран редактирования должен иметь правильный заголовок (с названием записи, если есть)
- При сохранении изменений должен быть возврат на главный экран (один уровень назад)
- На главном экране не должно оставаться зависших иконок редактирования или выделения
- Состояние swipe должно корректно сбрасываться при отпускании пальца

### Причина

Проблема в реализации SwipeToDismiss и навигации:

1. **Неправильная настройка SwipeToDismiss:**
   - SwipeToDismiss может быть настроен на открывание экрана при свайпе слева направо
   - Вместо обычного удаления или редактирования используется свайп для навигации
   - При неполном свайпе может срабатывать навигация несколько раз

2. **Неправильная навигация при свайпе:**
   - При свайпе слева направо может происходить многократная навигация
   - Навигация открывает несколько экземпляров CreateEditScreen подряд
   - Каждый экран добавляется в стек навигации, что приводит к множественным возвратам назад

3. **Проблема с заголовком экрана:**
   - При свайпе для редактирования открывается экран с заголовком "New Item"
   - Заголовок должен быть правильным (название записи или "Edit Item")
   - Это говорит о том, что itemId не передается корректно при навигации

4. **Не сбрасывается состояние свайпа:**
   - При отпускании пальца состояние swipe не возвращается в начальное
   - Визуальный эффект выделения/свайпа остается на элементе списка
   - Иконка редактирования может оставаться в "подсвеченном" состоянии

5. **Некорректное создание стеков навигации:**
   - При свайпе создается несколько экземпляров одного экрана
   - Стек навигации растет, что приводит к многократным нажатиям "назад"
   - Возможно, используется неправильный метод навигации (navigate вместо popBackStack)

### Шаги исправления

#### Шаг 11.1: Анализ текущей реализации свайпа для редактирования

**Задача:** Понять, как сейчас реализован свайп слева направо

**Действия:**
1. Изучить `MainScreen.kt`:
   - Найти SwipeToDismiss или Swipeable компонент для элементов списка
   - Проверить, есть ли разные направления свайпа (слева направо, справа налево)
   - Проверить, что происходит при свайпе слева направо
   - Проверить, как обрабатывается `DismissDirection.StartToEnd` (слева направо)

2. Изучить `ListItemView.kt` или компонент для отображения элементов:
   - Проверить, используется ли SwipeToDismiss
   - Проверить, какие действия выполняются при разных направлениях свайпа
   - Проверить наличие иконки редактирования и её поведение

3. Изучить `RootScreenComponents.kt`:
   - Проверить навигацию при вызове редактирования
   - Проверить, какой маршрут используется для редактирования
   - Проверить, передается ли itemId при навигации

#### Шаг 11.2: Исправление навигации при свайпе

**Задача:** Обеспечить открытие одного экрана редактирования с правильным заголовком

**Действия:**
1. Проверить направление свайпа:
   - Убедиться, что свайп слева направо направлен на редактирование
   - Проверить, что свайп справа налево направлен на удаление

2. Исправить навигацию при свайпе слева направо:
   - Вместо многократной навигации использовать однократную
   - Использовать правильный маршрут `Screen.EditItem.createRoute(itemId)`
   - Передавать корректный itemId из Item

3. Убедиться, что заголовок экрана правильный:
   - Проверить CreateEditScreen.kt и как он определяет заголовок
   - Проверить, что itemId передается корректно
   - Проверить, что при редактировании используется название записи в заголовке

4. Проверить, что не создается несколько экранов:
   - Использовать `navController.navigate()` однократно
   - Рассмотреть использование `navController.popBackStack()` если экран уже открыт

#### Шаг 11.3: Исправление состояния свайпа и выделения

**Задача:** Обеспечить корректный сброс состояния свайпа

**Действия:**
1. Проверить SwipeToDismiss конфигурацию:
   - Использовать `confirmValueChange` для контроля срабатывания свайпа
   - Убедиться, что свайп срабатывает только при достижении определенного порога
   - Предотвратить многократные срабатывания

2. Сбрасывать состояние swipe при отпускании:
   - Убедиться, что при `DismissValue.Settled` происходит сброс
   - Или использовать `animateTo` для корректного возвращения в начальное состояние
   - Убедиться, что визуальное выделение исчезает при отпускании пальца

3. Проверить иконку редактирования:
   - Убедиться, что иконка редактирования не остается в подсвеченном состоянии
   - Сбрасывать состояние иконки после свайпа
   - Убедиться, что иконка исчезает после навигации на экран редактирования

#### Шаг 11.4: Исправление возврата на главный экран

**Задача:** Обеспечить корректный возврат на главный экран после редактирования

**Действия:**
1. Проверить навигацию из CreateEditScreen:
   - Убедиться, что при сохранении происходит правильный возврат
   - Проверить, что не создается лишних экранов в стеке навигации

2. Убедиться, что стек навигации корректен:
   - После редактирования должен быть один уровень назад на главный экран
   - Не должно быть нескольких промежуточных экранов

3. Проверить, что главный экран не заблокирован:
   - После редактирования главный экран должен быть полностью функциональным
   - Не должно быть зависших иконок или выделения

**Критерий готовности:**
- ✅ Свайп слева направо открывает один экран редактирования
- ✅ Экран редактирования имеет правильный заголовок (с названием записи или "Edit Item")
- ✅ При сохранении происходит возврат на главный экран (один уровень назад)
- ✅ Нет промежуточных экранов между CreateEditScreen и MainScreen
- ✅ На главном экране нет зависших иконок редактирования или выделения
- ✅ При отпускании пальца свайп корректно возвращается в начальное состояние
- ✅ Визуальное выделение при свайпе исчезает при отпускании или навигации
- ✅ Несколько свайпов подряд не создают многократных экранов

---

## Стратегия тестирования

### Перед исправлениями

1. Запустить полный набор тестов для фиксации текущего состояния
2. Создать baseline screenshots для сравнения

### После каждого исправления

1. Проверить, что исправление решает проблему
2. Убедиться, что не появляются новые баги
3. Обновить тесты для покрытия исправлений
4. Обновить скриншоты для документации

### Финальное тестирование

1. Полное регрессионное тестирование всех функций
2. Проверка производительности
3. Проверка UX

---

## Зависимости

Эти исправления затрагивают следующие экраны и компоненты:

- **MainScreen.kt** - основной экран (баги #2, #3, #4, #5, #6, #8, #12)
- **ListItemView.kt** - компонент карточки (баги #6, #10, #12)
- **DetailScreen.kt** - экран деталей (баги #1, #11)
- **CreateEditScreen.kt** - экран создания/редактирования (баги #9, #12)
- **RootScreenComponents.kt** - навигация (баги #2, #7, #12)
- **MainScreenViewModel.kt** - ViewModel (баги #3, #5, #9)

---

## Критерии завершения

План считается выполненным, когда:

- ✅ Все 12 багов исправлены
- ✅ Все изменения протестированы
- ✅ Нет новых багов
- ✅ Производительность не ухудшилась
- ✅ UX улучшен

---

## История

- 2025-01-02: Создан план исправления на основе найденных 12 багов
- 2025-01-02: Исправлен баг #2 - Toolbar перекрывает контент списка (применены paddingValues)
- 2025-01-02: Исправлен баг #7 - Нижняя навигация не видна (заменен Column на Scaffold, NavigationBar перенесена в bottomBar)
- 2025-01-02: Исправлен баг #6 - Неправильная верстка ListItemView (разделение на 70%/30%, ограничения maxLines и TextOverflow)
- 2025-01-02: Исправлен баг #8 - Контент заезжает под камеру (заменен Column на Scaffold, применены paddingValues к NavHost)