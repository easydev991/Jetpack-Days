# План исправления багов после внедрения DI через Factory Methods

**Дата создания:** 2025-01-02  
**Статус:** В ПРОЦЕССЕ РАБОТЫ

---

## Обзор проблем

После внедрения factory методов для CreateEditScreenViewModel и DetailScreenViewModel обнаружены следующие проблемы, требующие исправления:

1. ✅ **Баг #1**: DetailScreen не обновляется после редактирования (ИСПРАВЛЕН)
2. ✅ **Баг #2**: Toolbar перекрывает контент списка (ИСПРАВЛЕН)
3. ✅ **Баг #3**: Удаление записей работает некорректно (ИСПРАВЛЕН)
4. ❌ **Баг #4**: Поиск не работает
5. ❌ **Баг #5**: Пропадание записей при поиске
6. ✅ **Баг #6**: Неправильная верстка ListItemView (ИСПРАВЛЕН)
7. ✅ **Баг #7**: Нижняя навигация не видна (ИСПРАВЛЕН)
8. ✅ **Баг #8**: Контент заезжает под камеру (ИСПРАВЛЕН)
9. ✅ **Баг #9**: Изменение displayOption не обновляет UI (ИСПРАВЛЕН)
10. ✅ **Баг #10**: Свайп слева направо открывает несколько экранов редактирования (ИСПРАВЛЕН)
11. ✅ **Баг #11**: Состояние свайпа не сбрасывается при отмене удаления в диалоговом окне (ИСПРАВЛЕН)
12. ✅ **Баг #12**: Кнопка "Сохранить" активна без изменений (ИСПРАВЛЕН)
13. ❌ **Баг #13**: Заголовок экрана создания/редактирования всегда одинаковый
14. ✅ **Баг #14**: Месяцы игнорируются в MONTH_DAY и YEAR_MONTH_DAY (ИСПРАВЛЕН)
15. ✅ **Баг #15**: DetailScreen игнорирует displayOption

---

| Баг | Приоритет | Влияние | Сложность | Оценка |
|------|------------|-----------|----------|----------|---------|
| #1   | Высокий    | Высокое   | Средняя   | 2-3 ч   |
| #2   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #3   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #4   | Высокий    | Высокое   | Средняя   | 2-3 ч    |
| #5   | Высокий    | Высокое   | Средняя   | 2-4 ч    |
| #6   | Средний    | Среднее   | Низкая    | 1 ч       |
| #7   | Средний    | Среднее   | Низкая    | 1 ч       |
| #8   | Средний    | Среднее   | Низкая    | 1-2 ч     |
| #9   | Низкий     | Низкое    | Низкая    | 1-2 ч     |
| #10  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #11  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #12  | Средний    | Среднее   | Средняя   | 2-3 ч     |
| #13  | Низкий     | Низкое    | Низкая    | 0.5-1 ч   |
| #14  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #15  | Высокий    | Высокое   | Низкая    | 1-2 ч     |

---

## Исправленные баги

| #    | Описание                                       | Дата исправления |
|-----|-----------------------------------------------|----------------|
| #1  | DetailScreen не обновляется после редактирования      | 2025-01-02     |
| #2  | Toolbar перекрывает контент списка                 | 2025-01-02     |
| #3  | Удаление записей работает некорректно             | 2025-01-02     |
| #6  | Неправильная верстка ListItemView                | 2025-01-02     |
| #7  | Нижняя навигация не видна                       | 2025-01-02     |
| #8  | Контент заезжает под камеру                     | 2025-01-02     |
| #9  | Изменение displayOption не обновляет UI           | 2025-01-02     |
| #10 | Свайп слева направо открывает несколько экранов  | 2025-01-02     |
| #11 | Состояние свайпа не сбрасывается                | 2025-01-02     |
| #12 | Кнопка "Сохранить" активна без изменений        | 2025-01-02     |
| #14  | Месяцы игнорируются в MONTH_DAY и YEAR_MONTH_DAY | 2025-01-02     |
| #15  | DetailScreen игнорирует displayOption             | 2025-01-02     |

---

## Баг #1: DetailScreen не обновляется после редактирования ✅ **ИСПРАВЛЕН**

### Решение
Добавлены `getItemByIdFlow()` в ItemDao и `getItemFlow()` в ItemRepository. DetailScreenViewModel использует Flow с SharingStarted.WhileSubscribed(5000) для автоматической перезагрузки.

**Дата исправления: 2025-01-02**

---

## Баг #2: Toolbar перекрывает контент списка ✅ **ИСПРАВЛЕН**

### Решение
Добавлен параметр `paddingValues` и применен `contentPadding` к LazyColumn.

**Дата исправления: 2025-01-02**

---

## Баг #3: Удаление записей работает некорректно ✅ **ИСПРАВЛЕН**

### Решение
Свайп заменен на долгое нажатие с DropdownMenu (View, Edit, Delete). Меню позиционируется в месте нажатия, элемент подсвечивается.

**Дата исправления: 2025-01-02**

---

## Баг #4: Поиск не работает

### Описание
При вводе в поиск названий записей ничего не происходит.

### Причина
SearchBar может не отправлять запрос в ViewModel при нажатии Enter. Отсутствует явная обработка события подтверждения поиска.

### Шаги исправления

#### Шаг 4.1: Анализ SearchBar ✅
Изучена текущая реализация SearchBar в MainScreen.kt: параметры, обработка `onQueryChange` и `onSearch`.

#### Шаг 4.2: Исправление обработки поиска
**Задача:** Обеспечить работу поиска

**Действия:**
1. Добавить обработку `onActiveChange` для отслеживания состояния фокуса
2. При потере фокуса выполнять поиск
3. Добавить обработку нажатия Enter
4. Убедиться, что фильтрация работает для всех записей

**Критерий готовности:**
- ✅ Поиск работает при вводе текста
- ✅ Поиск выполняется при нажатии на Enter
- ✅ Результаты поиска отображаются корректно

---

## Баг #5: Пропадание записей при поиске

### Описание

**Проблема 1 (пропадание записей):**
Иногда при переходе в режим поиска и обратно, или при нажатии на плюс для создания новой записи внезапно пропадают почти все записи с главного экрана кроме одной, а потом могут появиться при очередном появлении главного экрана - например, если нажать на иконку поиска, ввести что-то, а потом нажать на кнопку с плюсом, и потом вернуться назад - большинство записей не будет видно - они как будто скрыаются вертикально наверх.

**Проблема 2 (кнопка создания видна при поиске):**
Кнопка с плюсом (которая открывает экран создания записи) остается видимой при переходе в режим поиска, что может привести к путанице и конфликтам состояний.

**Требование:**
При переходе в режим поиска кнопку с плюсом нужно скрывать, чтобы избежать смешивания состояний "поиска" и "создания записи". Кнопка должна быть видна только когда поиск не активен.

### Причина

Проблема в управлении состоянием Flow и UI:

1. **Конфликт состояний при поиске:**
   - При активном поиске фильтрация может конфликтовать с другим состоянием
   - При создании новой записи при активном поиске происходит сброс состояния
   - Отсутствует правильное сохранение состояния при навигации между экранами

2. **Кнопка создания не учитывает состояние поиска:**
   - Кнопка с плюсом всегда видима на MainScreen
   - Нет проверки на активный режим поиска
   - Пользователь может нажать плюс при активном поиске, что вызывает путаницу

### Шаги исправления

#### Шаг 5.1: Анализ потока данных

**Задача:** Понять причину пропадания записей и проверить состояние кнопки

**Действия:**
1. Изучить `MainScreenViewModel.observeItems()`
2. Проверить логику фильтрации
3. Проверить состояние `searchQuery` при навигации
4. Проверить сохранение состояния при создании новой записи
5. Изучить верстку MainScreen.kt и найти кнопку с плюсом
6. Проверить, есть ли состояние для активного режима поиска в ViewModel

#### Шаг 5.2: Исправление управления состоянием

**Задача 1:** Сохранять состояние поиска правильно

**Действия:**
1. Сохранять состояние поиска при навигации на DetailScreen
2. Сохранять состояние поиска при навигации на CreateEditScreen
3. Восстанавливать состояние при возврате на MainScreen
4. Убедиться, что состояние не сбрасывается неожиданно

**Задача 2:** Скрыть кнопку создания при активном поиске

**Действия:**
1. Добавить состояние для отслеживания активного режима поиска в MainScreenViewModel (если нет)
2. Передать это состояние в UI MainScreen
3. В верстке MainScreen.kt добавить условие видимости для кнопки с плюсом:
   - Показывать кнопку только когда `!isSearchActive`
   - Или использовать флаг/переменную для управления видимостью
4. Проверить, что при выходе из режима поиска кнопка снова становится видимой
5. Убедиться, что скрытие кнопки не ломает навигацию и UX

**Критерий готовности:**
- ✅ При переходе к поиску записи не пропадают
- ✅ При создании новой записи состояние поиска сохраняется
- ✅ При возврате на главный экран состояние восстанавливается
- ✅ Записи отображаются корректно в любой момент
- ✅ Кнопка с плюсом скрывается при активном режиме поиска
- ✅ Кнопка с плюсом отображается когда поиск не активен
- ✅ Нет конфликтов между режимом поиска и созданием записи

---

## Баг #6: Неправильная верстка ListItemView ✅ **ВЫПОЛНЕН**

### Решение
Контент разделен на две части (70%/30%), добавлены `maxLines = 2` и `TextOverflow.Ellipsis` для названия и описания.

### Дата исправления: 2025-01-02

---

## Баг #7: Нижняя навигация не видна ✅ **ИСПРАВЛЕН**

### Решение
В RootScreen заменен `Column` на `Scaffold`, NavigationBar перенесена в `bottomBar`. Добавлена передача `paddingValues` в `navHostContent()`.

### Дата исправления: 2025-01-02

---

## Баг #8: Контент заезжает под камеру ✅ **ИСПРАВЛЕН**

### Решение
В RootScreen заменен `Column` на `Scaffold` (выполнено в баге #7), применены `paddingValues` к NavHost.

### Дата исправления: 2025-01-02

---

## Баг #9: Изменение displayOption не обновляет UI ✅ **ИСПРАВЛЕН**

### Решение
**CreateEditScreen:** Добавлен параметр `displayOption` в previewDaysContentInner(), форматирование через `GetFormattedDaysForItemUseCase`.
**MainScreen:** Форматирование через `getFormattedDaysForItemUseCase(item)` вместо `NumberFormattingUtils.formatDaysCount()`.

**Дата исправления: 2025-01-02**

---

## Баг #10: Свайп слева направо открывает несколько экранов редактирования ✅ **ИСПРАВЛЕН**

### Решение
Свайп заменен на долгое нажатие с DropdownMenu (View, Edit, Delete). Опция "Edit" открывает один экран редактирования с правильным заголовком.

---

## Баг #11: Состояние свайпа не сбрасывается при отмене удаления в диалоговом окне ✅ **ИСПРАВЛЕН**

### Решение
Свайп заменен на долгое нажатие с DropdownMenu (View, Edit, Delete). Меню закрывается сразу после выбора любого действия.

---

## Баг #12: Кнопка "Сохранить" активна без изменений ✅ **ИСПРАВЛЕН**

### Решение
Добавлено хранение оригинальных данных (`_originalItem`, `_hasChanges`), метод `checkHasChanges()` сравнивает поля с оригинальными. Логика кнопки: для новых записей `enabled = isValidData`, для редактирования `enabled = isValidData && hasChanges`.

**Дата исправления: 2025-01-02**

---

## Баг #13: Заголовок экрана создания/редактирования всегда одинаковый

### Описание

На экране создания/изменения записи всегда отображается одинаковый заголовок "New Item", независимо от того, создается новая запись или редактируется существующая.

**Проблема:**
- При создании новой записи заголовок должен быть "New Item" (как сейчас)
- При редактировании существующей записи заголовок должен быть "Edit Item"
- В настоящий момент заголовок всегда "New Item" для обоих сценариев

**Требование:**
- При создании новой записи заголовок экрана должен быть "New Item"
- При редактировании существующей записи заголовок экрана должен быть "Edit Item"
- Для обоих заголовков должна быть локализация (русский и английский)

### Причина

Вероятно, в CreateEditScreen не проверяется режим работы (создание или редактирование) при формировании заголовка. Заголовок может быть захардкожен или не зависит от наличия itemId.

### Шаги исправления

#### Шаг 13.1: Анализ текущей реализации заголовка

**Задача:** Понять, как сейчас формируется заголовок на CreateEditScreen

**Действия:**
1. Изучить `CreateEditScreen.kt`:
   - Найти компонент заголовка (TopAppBar или Scaffold)
   - Проверить, как задается заголовок (хардкод или переменная)
   - Проверить, есть ли условная логика для создания/редактирования
2. Изучить навигацию:
   - Проверить, как передается itemId при редактировании
   - Проверить, как определяется режим создания/редактирования
3. Проверить наличие локализации для заголовков

#### Шаг 13.2: Добавление строк локализации

**Задача:** Добавить локализованные строки для обоих заголовков

**Действия:**
1. Добавить строковые ресурсы:
   - `res/values/strings.xml`: `new_item_title` = "New Item"
   - `res/values/strings.xml`: `edit_item_title` = "Edit Item"
   - `res/values-ru/strings.xml`: `new_item_title` = "Новая запись"
   - `res/values-ru/strings.xml`: `edit_item_title` = "Изменить запись"
2. Проверить соответствие существующему стилю локализации

#### Шаг 13.3: Реализация условного заголовка

**Задача:** Сделать заголовок зависимым от режима работы

**Действия:**
1. Добавить логику определения режима создания/редактирования:
   - Если itemId != null -> режим редактирования -> использовать `edit_item_title`
   - Если itemId == null -> режим создания -> использовать `new_item_title`
2. Обновить компонент заголовка в CreateEditScreen:
   - Использовать условную логику для выбора заголовка
   - Пример: `title = if (itemId != null) stringResource(R.string.edit_item_title) else stringResource(R.string.new_item_title)`
3. Убедиться, что заголовок корректно отображается при обоих сценариях

**Критерий готовности:**
- ✅ При создании новой записи отображается заголовок "New Item" (или "Новая запись" на русском)
- ✅ При редактировании существующей записи отображается заголовок "Edit Item" (или "Изменить запись" на русском)
- ✅ Оба заголовка локализованы на русском и английском языках
- ✅ При переключении языка заголовки корректно меняются
- ✅ Нет случаев, когда заголовок остается "New Item" при редактировании

---

## Баг #14: Месяцы игнорируются в MONTH_DAY и YEAR_MONTH_DAY ✅ **ИСПРАВЛЕН**

### Описание
**ПРОБЛЕМА:** При выборе DisplayOption.MONTH_DAY, если прошло больше года, годы не конвертируются в месяцы.

**Пример 2 (больше года - ИСПРАВЛЕНО):**
- Разница: 1454 дня (4 года)
- **MONTH_DAY**: "48 мес X дн" ✅ (было "0 мес X дн" ❌)
- **YEAR_MONTH_DAY**: "4 г X дн" ✅

### Решение
**DaysFormatterImpl.formatMonthDay():** Добавлена конвертация `totalMonths = period.years * 12 + period.months`. Удалены лишние пробелы в `buildComponentsList()`.
**DaysFormatterImpl.formatYearMonthDay():** Без изменений (использует period.years без конвертации).

**Unit-тесты:**
- `formatComposite when MONTH_DAY option with years then converts years to months()` - 4 года → 48 месяцев
- `formatComposite when MONTH_DAY option with years and months then sums all months()` - 1 год + 2 месяца → 14 месяцев
- `formatComposite when YEAR_MONTH_DAY option with years then does NOT convert years to months()` - без конвертации

### Дата исправления: 2025-01-02

---

## Баг #15: DetailScreen игнорирует displayOption ✅ **ИСПРАВЛЕН**

### Описание
На DetailScreen displayOption игнорируется, всегда отображается только количество дней.

### Решение
**DetailScreen.kt:** Созданы use cases через FormatterModule, GetFormattedDaysForItemUseCase передается в detailScreenContent().
**DetailContent.kt:** daysCountSection() использует getFormattedDaysForItemUseCase для форматирования с учетом displayOption. Fallback на calculateDaysText() для preview.

### Результат
DetailScreen использует GetFormattedDaysForItemUseCase, форматирование учитывает displayOption, логика остается в use cases (как на MainScreen и CreateEditScreen).

### Дата исправления: 2025-01-02

---

## Стратегия тестирования

### Перед исправлениями

1. Запустить полный набор тестов для фиксации текущего состояния
2. Создать baseline screenshots для сравнения

### После каждого исправления

1. Проверить, что исправление решает проблему
2. Убедиться, что не появляются новые баги
3. Обновить тесты для покрытия исправлений
4. Обновить скриншоты для документации

### Финальное тестирование

1. Полное регрессионное тестирование всех функций
2. Проверка производительности
3. Проверка UX

---

## Зависимости

Эти исправления затрагивают следующие экраны и компоненты:

- **MainScreen.kt** - основной экран (баги #2, #3, #4, #5, #6, #8, #11, #14)
- **ListItemView.kt** - компонент карточки (баги #6, #11, #14)
- **DetailScreen.kt** - экран деталей (баги #1, #10, #15)
- **CreateEditScreen.kt** - экран создания/редактирования (баги #9, #10, #11, #13, #14)
- **RootScreenComponents.kt** - навигация (баги #2, #7, #11)
- **MainScreenViewModel.kt** - ViewModel (баги #3, #5, #9, #14)
- **CreateEditScreenViewModel.kt** - ViewModel (баг #12)
- **DetailContent.kt** - компонент деталей (баг #15)
- **DaysFormatterImpl.kt** - форматирование (баг #14)
- **CalculateDaysDifferenceUseCase.kt** - вычисление разницы дат (баг #14)
- **FormatDaysTextUseCase.kt** - форматирование текста (баг #14)
- **GetFormattedDaysForItemUseCase.kt** - получение форматированного текста (баг #14)
- **DisplayOption.kt** - модель опции отображения (баг #14)
- **TimePeriod.kt** - модель периода времени (баг #14)

---

## Критерии завершения

План считается выполненным, когда:

- ✅ Все 15 багов исправлены
- ✅ Все изменения протестированы
- ✅ Нет новых багов
- ✅ Производительность не ухудшилась
- ✅ UX улучшен

---

## История

- 2025-01-02: Создан план исправления на основе найденных 12 багов
- 2025-01-02: Добавлены баги #13, #14, #15
- 2025-01-02: Исправлены баги #1, #2, #6, #7, #8, #9, #10, #11, #12, #14, #15