# План исправления багов после внедрения DI через Factory Methods

**Дата создания:** 2025-01-02  
**Статус:** НАЧАЛО РАБОТЫ

---

## Обзор проблем

После внедрения factory методов для CreateEditScreenViewModel и DetailScreenViewModel обнаружены следующие проблемы, требующие исправления:

1. ✅ **Баг #1**: DetailScreen не обновляется после редактирования (ИСПРАВЛЕН)
2. ✅ **Баг #2**: Toolbar перекрывает контент списка (ИСПРАВЛЕН)
3. ✅ **Баг #3**: Удаление записей работает некорректно (ИСПРАВЛЕН)
4. ❌ **Баг #4**: Поиск не работает
5. ❌ **Баг #5**: Пропадание записей при поиске
6. ✅ **Баг #6**: Неправильная верстка ListItemView (ИСПРАВЛЕН)
7. ✅ **Баг #7**: Нижняя навигация не видна (ИСПРАВЛЕН)
8. ✅ **Баг #8**: Контент заезжает под камеру (ИСПРАВЛЕН)
9. ❌ **Баг #9**: Изменение displayOption не обновляет UI
10. ✅ **Баг #10**: Свайп слева направо открывает несколько экранов редактирования (ИСПРАВЛЕН)
11. ✅ **Баг #11**: Состояние свайпа не сбрасывается при отмене удаления в диалоговом окне (ИСПРАВЛЕН)
12. ✅ **Баг #12**: Кнопка "Сохранить" активна без изменений (ИСПРАВЛЕН)
13. ❌ **Баг #13**: Заголовок экрана создания/редактирования всегда одинаковый

---

| Баг | Приоритет | Влияние | Сложность | Оценка |
|------|------------|-----------|----------|----------|---------|
| #1   | Высокий    | Высокое   | Средняя   | 2-3 ч   |
| #2   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #3   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #4   | Высокий    | Высокое   | Средняя    | 2-3 ч    |
| #5   | Высокий    | Высокое   | Средняя    | 2-4 ч    |
| #6   | Средний    | Среднее   | Низкая    | 1 ч       |
| #7   | Средний    | Среднее   | Низкая    | 1 ч       |
| #8   | Средний    | Среднее   | Низкая    | 1-2 ч     |
| #9   | Низкий     | Низкое    | Низкая    | 1-2 ч     |
| #10  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #11  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #12  | Средний    | Среднее   | Средняя   | 2-3 ч     |
| #13  | Низкий     | Низкое    | Низкая    | 0.5-1 ч   |

---

## Баг #1: DetailScreen не обновляется после редактирования ✅ **ИСПРАВЛЕН**

### Описание
При возврате с экрана редактирования на DetailScreen отображались старые данные вместо актуальных.

### Решение
Добавлены методы `getItemByIdFlow()` в ItemDao и `getItemFlow()` в ItemRepository. DetailScreenViewModel переписан для использования Flow вместо однократной загрузки. Flow с SharingStarted.WhileSubscribed(5000) обеспечивает автоматическую перезагрузку при появлении экрана.

**Критерий готовности:**
- ✅ DetailScreen показывает обновленные данные сразу после возврата
- ✅ Автоматическое обновление через Flow работает
- ✅ Проблема кэширования решена

**Дата исправления: 2025-01-02**

---

## Баг #2: Toolbar перекрывает контент списка ✅ **ИСПРАВЛЕН**

### Описание
Список записей на главном экране перекрывался верхним тулбаром.

### Решение
Добавлен параметр `paddingValues`, применено `contentPadding` к `LazyColumn` и в функциях с пустым контентом.

**Критерий готовности:**
- ✅ Список записей отображается полностью
- ✅ AppBar не перекрывает контент списка

**Дата исправления: 2025-01-02**

---

## Баг #3: Удаление записей работает некорректно ✅ **ИСПРАВЛЕН**

### Описание
Вместо свайпа реализовано долгое нажатие с контекстным меню для устранения проблем с состоянием свайпа.

### Решение
Долгое нажатие открывает DropdownMenu с опциями View, Edit, Delete. Меню позиционируется в месте нажатия. При открытии контекстного меню элемент подсвечивается с плавной анимацией цвета фона.

**Критерий готовности:**
- ✅ Удаление записей работает через долгое нажатие
- ✅ При долгом нажатии открывается контекстное меню
- ✅ Элемент подсвечивается при открытии меню
- ✅ Анимация выделения работает плавно
- ✅ Контекстное меню позиционируется в месте нажатия

**Дата исправления: 2025-01-02**

---

## Баг #4: Поиск не работает

### Описание
При вводе в поиск названий записей ничего не происходит.

### Причина
SearchBar может не отправлять запрос в ViewModel при нажатии Enter. Отсутствует явная обработка события подтверждения поиска.

### Шаги исправления

#### Шаг 4.1: Анализ SearchBar ✅
Изучена текущая реализация SearchBar в MainScreen.kt: параметры, обработка `onQueryChange` и `onSearch`.

#### Шаг 4.2: Исправление обработки поиска
**Задача:** Обеспечить работу поиска

**Действия:**
1. Добавить обработку `onActiveChange` для отслеживания состояния фокуса
2. При потере фокуса выполнять поиск
3. Добавить обработку нажатия Enter
4. Убедиться, что фильтрация работает для всех записей

**Критерий готовности:**
- ✅ Поиск работает при вводе текста
- ✅ Поиск выполняется при нажатии на Enter
- ✅ Результаты поиска отображаются корректно

---

## Баг #5: Пропадание записей при поиске

### Описание

**Проблема 1 (пропадание записей):**
Иногда при переходе в режим поиска и обратно, или при нажатии на плюс для создания новой записи внезапно пропадают почти все записи с главного экрана кроме одной, а потом могут появиться при очередном появлении главного экрана - например, если нажать на иконку поиска, ввести что-то, а потом нажать на кнопку с плюсом, и потом вернуться назад - большинство записей не будет видно - они как будто скрыаются вертикально наверх.

**Проблема 2 (кнопка создания видна при поиске):**
Кнопка с плюсом (которая открывает экран создания записи) остается видимой при переходе в режим поиска, что может привести к путанице и конфликтам состояний.

**Требование:**
При переходе в режим поиска кнопку с плюсом нужно скрывать, чтобы избежать смешивания состояний "поиска" и "создания записи". Кнопка должна быть видна только когда поиск не активен.

### Причина

Проблема в управлении состоянием Flow и UI:

1. **Конфликт состояний при поиске:**
   - При активном поиске фильтрация может конфликтовать с другим состоянием
   - При создании новой записи при активном поиске происходит сброс состояния
   - Отсутствует правильное сохранение состояния при навигации между экранами

2. **Кнопка создания не учитывает состояние поиска:**
   - Кнопка с плюсом всегда видима на MainScreen
   - Нет проверки на активный режим поиска
   - Пользователь может нажать плюс при активном поиске, что вызывает путаницу

### Шаги исправления

#### Шаг 5.1: Анализ потока данных

**Задача:** Понять причину пропадания записей и проверить состояние кнопки

**Действия:**
1. Изучить `MainScreenViewModel.observeItems()`
2. Проверить логику фильтрации
3. Проверить состояние `searchQuery` при навигации
4. Проверить сохранение состояния при создании новой записи
5. Изучить верстку MainScreen.kt и найти кнопку с плюсом
6. Проверить, есть ли состояние для активного режима поиска в ViewModel

#### Шаг 5.2: Исправление управления состоянием

**Задача 1:** Сохранять состояние поиска правильно

**Действия:**
1. Сохранять состояние поиска при навигации на DetailScreen
2. Сохранять состояние поиска при навигации на CreateEditScreen
3. Восстанавливать состояние при возврате на MainScreen
4. Убедиться, что состояние не сбрасывается неожиданно

**Задача 2:** Скрыть кнопку создания при активном поиске

**Действия:**
1. Добавить состояние для отслеживания активного режима поиска в MainScreenViewModel (если нет)
2. Передать это состояние в UI MainScreen
3. В верстке MainScreen.kt добавить условие видимости для кнопки с плюсом:
   - Показывать кнопку только когда `!isSearchActive`
   - Или использовать флаг/переменную для управления видимостью
4. Проверить, что при выходе из режима поиска кнопка снова становится видимой
5. Убедиться, что скрытие кнопки не ломает навигацию и UX

**Критерий готовности:**
- ✅ При переходе к поиску записи не пропадают
- ✅ При создании новой записи состояние поиска сохраняется
- ✅ При возврате на главный экран состояние восстанавливается
- ✅ Записи отображаются корректно в любой момент
- ✅ Кнопка с плюсом скрывается при активном режиме поиска
- ✅ Кнопка с плюсом отображается когда поиск не активен
- ✅ Нет конфликтов между режимом поиска и созданием записи

---

## Баг #6: Неправильная верстка ListItemView ✅ **ВЫПОЛНЕН**

### Описание
В UI-компоненте неправильно расположены тексты: отсутствует разделение ширины, нет ограничений на количество строк.

### Решение
Разделен контент на две части (70%/30%), добавлены `maxLines = 2` и `TextOverflow.Ellipsis` для названия и описания.

**Критерий готовности:**
- ✅ Текст с количеством дней занимает не более 30% ширины
- ✅ Название и описание ограничены до 2 строк
- ✅ Длинный текст обрезается с многоточием

### Дата исправления: 2025-01-02

---

## Баг #7: Нижняя навигация не видна ✅ **ИСПРАВЛЕН**

### Описание
Нижняя панель навигации всегда была не видна.

### Решение
В RootScreen заменен `Column` на `Scaffold`, NavigationBar перенесена в параметр `bottomBar` Scaffold. Добавлена передача `paddingValues` из Scaffold в `navHostContent()`. Добавлено `contentWindowInsets = WindowInsets(0, 0, 0, 0)` для отключения автоматических отступов StatusBar.

**Критерий готовности:**
- ✅ На MainScreen видна NavigationBar с двумя вкладками
- ✅ На DetailScreen и CreateEditScreen NavigationBar скрыта
- ✅ При переключении вкладок работает корректно
- ✅ Нет лишнего пространства над заголовком экрана

### Дата исправления: 2025-01-02

---

## Баг #8: Контент заезжает под камеру ✅ **ИСПРАВЛЕН**

### Описание
При повороте экрана контент заезжал под переднюю камеру.

### Решение
В RootScreen заменен `Column` на `Scaffold` (выполнено в баге #7). Переданы `paddingValues` из Scaffold в `navHostContent()` и применены к NavHost через Modifier.padding().

**Критерий готовности:**
- ✅ Контент не заезжает под камеру
- ✅ При повороте экрана контент отображается корректно

### Дата исправления: 2025-01-02

---

## Баг #9: Изменение displayOption не обновляет UI ✅ **ИСПРАВЛЕН**

### Описание

**Проблема 1 (на CreateEditScreen):**
На экране создания/изменения записи можно выбирать display format, но его изменение не приводит к обновлению preview на этом же экране - форматирование дней остается прежним, хотя выбран другой displayOption.

**Проблема 2 (на MainScreen):**
После сохранения записи с измененным displayOption, форматирование на главном экране также остается прежним - MainScreen не пересчитывает форматирование при изменении displayOption.

**Требование:**
- При изменении displayOption на экране CreateEditScreen должен сразу обновляться preview с новым форматированием
- При сохранении записи с измененным displayOption, форматирование на MainScreen должно обновляться
- Изменения displayOption должны отражаться во всех компонентах, которые показывают форматирование дней

### Причина

Проблема в реактивном обновлении на разных экранах:

1. **На CreateEditScreen:**
   - DisplayOption хранится в состоянии ViewModel, но UI не реагирует на изменения этого поля
   - Preview на CreateEditScreen использует кэшированное значение или не подписан на изменения displayOption
   - Возможно, форматирование выполняется один раз при инициализации и не обновляется

2. **На MainScreen:**
   - DisplayOption сохраняется в записи в базе данных, но MainScreen не пересчитывает форматирование
   - ListItemView может использовать устаревшее форматирование
   - Отсутствует реактивная связь между displayOption в Item и форматированием

### Решение

**Исправлено реактивное форматирование с учетом displayOption:**

1. **На CreateEditScreen (CreateEditPreviewComponents.kt):**
   - Добавлен параметр `displayOption` в функцию `previewDaysContentInner()`
   - Созданы use cases для форматирования (`GetFormattedDaysForItemUseCase`, `FormatDaysTextUseCase`, `CalculateDaysDifferenceUseCase`)
   - Форматирование дней теперь выполняется через `GetFormattedDaysForItemUseCase` с учетом выбранного displayOption
   - Preview автоматически обновляется при изменении displayOption в UI

2. **На MainScreen (MainScreen.kt):**
   - Создан экземпляр `GetFormattedDaysForItemUseCase` при инициализации экрана
   - В `itemsListContent()` форматирование дней теперь выполняется через `getFormattedDaysForItemUseCase(item)` вместо `NumberFormattingUtils.formatDaysCount()`
   - Форматирование автоматически учитывает displayOption из каждой записи
   - При обновлении Item в базе данных (через Flow) список автоматически перерисовывается с новым форматированием

**Критерий готовности:**
- ✅ При изменении displayOption на CreateEditScreen preview обновляется немедленно
- ✅ Форматирование дней на CreateEditScreen соответствует выбранному displayOption
- ✅ При сохранении записи displayOption корректно сохраняется в базе данных
- ✅ При загрузке записи из базы displayOption присутствует и корректен
- ✅ При изменении displayOption форматирование на MainScreen обновляется автоматически
- ✅ Изменения displayOption отражаются во всех компонентах (CreateEditScreen preview, MainScreen список)
- ✅ Форматирование дней соответствует выбранному displayOption везде

**Дата исправления: 2025-01-02**

---

## Баг #10: Свайп слева направо открывает несколько экранов редактирования ✅ **ИСПРАВЛЕН**

### Описание
Свайп слева направо открывал несколько экранов редактирования подряд, создавал лишние уровни в стеке навигации.

### Решение
Свайп полностью заменен на долгое нажатие с контекстным меню. При долгом нажатии открывается DropdownMenu с опциями View, Edit, Delete. Опция "Edit" открывает только один экран редактирования с правильным заголовком, при сохранении происходит возврат на главный экран (один уровень назад).

**Критерий готовности:**
- ✅ Опция "Edit" открывает один экран редактирования
- ✅ Экран редактирования имеет правильный заголовок (с названием записи)
- ✅ При сохранении происходит возврат на главный экран (один уровень назад)
- ✅ На главном экране нет зависших иконок редактирования или выделения

---

## Баг #11: Состояние свайпа не сбрасывается при отмене удаления в диалоговом окне ✅ **ИСПРАВЛЕН**

### Описание
При отмене удаления в диалоговом окне возникали проблемы с визуальным состоянием элементов списка.

### Решение
Свайп полностью заменен на долгое нажатие с контекстным меню. При долгом нажатии открывается DropdownMenu с опциями View, Edit, Delete. Контекстное меню закрывается сразу после выбора любого действия. Нет необходимости в дополнительных действиях для сброса состояния.

**Критерий готовности:**
- ✅ При долгом нажатии открывается контекстное меню
- ✅ При отмене удаления нет проблем с визуальным состоянием
- ✅ Элемент списка возвращается в нормальное визуальное состояние
- ✅ Нет необходимости в дополнительных действиях для сброса состояния

---

## Баг #12: Кнопка "Сохранить" активна без изменений ✅ **ИСПРАВЛЕН**

### Описание

На экране редактирования существующей записи кнопка "Сохранить" активна всегда, даже если пользователь не внес никаких изменений. Кнопка должна быть недоступна (disabled), если не было изменений по сравнению с исходными данными, и доступной только при наличии изменений.

**Для новых записей логика уже корректная:**
- Кнопка "Создать" недоступна до ввода данных
- Кнопка становится доступной при наличии валидных данных

**Для редактирования существующих записей:**
- Кнопка "Сохранить" всегда активна, даже без изменений
- Нет отслеживания изменений по сравнению с исходными данными
- Пользователь может нажать "Сохранить" без реальных изменений

**Требование:**
- При открытии экрана редактирования кнопка "Сохранить" должна быть недоступна
- Кнопка должна стать доступной только когда пользователь внес изменения
- При возвращении всех полей к исходным значениям кнопка снова должна стать недоступной

### Причина

Проблема в логике отслеживания изменений в CreateEditScreenViewModel:

1. **Отсутствует сравнение с исходными данными:**
   - ViewModel не сохраняет начальное состояние записи при открытии экрана редактирования
   - Нет механизма сравнения текущих значений с исходными
   - Состояние кнопки не зависит от наличия изменений

2. **Логика для новых записей отличается:**
   - Для новых записей используется проверка на валидность данных
   - Для редактирования используется другая логика (или отсутствует)
   - Нет унифицированного подхода к управлению состоянием кнопки

### Решение

**Реализовано отслеживание изменений при редактировании:**

1. **Добавлено хранение оригинальных данных в CreateEditScreenViewModel:**
   - `private val _originalItem = MutableStateFlow<Item?>(null)` - хранит оригинальные данные записи
   - `private val _hasChanges = MutableStateFlow(false)` - отслеживает наличие изменений
   - При загрузке записи сохраняются оригинальные данные и сбрасывается флаг изменений

2. **Добавлен метод `checkHasChanges()`:**
   - Сравнивает текущие значения полей (title, details, timestamp, colorTag, displayOption) с оригинальными
   - Вызывается при каждом изменении любого поля в UI

3. **Обновлены компоненты UI для отслеживания изменений:**
   - `titleSection()` и `detailsSection()` добавлен параметр `onValueChange`
   - `colorSelector()`, `colorOptionSurface()`, `noColorOptionSurface()` добавлен параметр `onValueChange`
   - `displayOptionSelector()`, `displayOptionSurface()` добавлен параметр `onValueChange`
   - `dateSection()` добавлен параметр `onValueChange` при открытии DatePicker

4. **Обновлена логика кнопки "Сохранить" в `saveButton()`:**
   - Для новых записей: `enabled = isValidData` (проверка валидности данных)
   - Для редактирования: `enabled = isValidData && hasChanges` (валидность + наличие изменений)
   - Кнопка соблюдает разные правила для создания и редактирования

5. **Добавлен метод `resetHasChanges()`:**
   - Сбрасывает флаг изменений
   - Вызывается при успешном сохранении записи

**Критерий готовности:**
- ✅ При открытии экрана редактирования кнопка "Сохранить" недоступна
- ✅ При изменении любого поля кнопка становится доступной
- ✅ При возврате всех полей к исходным значениям кнопка снова недоступна
- ✅ Для новых записей логика кнопки "Создать" работает корректно (без изменений)
- ✅ Состояние кнопки корректно обновляется при быстрых изменениях
- ✅ Нет задержек в обновлении состояния кнопки
- ✅ После сохранения записи состояние корректно сбрасывается
- ✅ Логика работает для всех полей (title, details, timestamp, colorTag, displayOption)

**Дата исправления: 2025-01-02**

---

## Баг #13: Заголовок экрана создания/редактирования всегда одинаковый

### Описание

На экране создания/изменения записи всегда отображается одинаковый заголовок "New Item", независимо от того, создается новая запись или редактируется существующая.

**Проблема:**
- При создании новой записи заголовок должен быть "New Item" (как сейчас)
- При редактировании существующей записи заголовок должен быть "Edit Item"
- В настоящий момент заголовок всегда "New Item" для обоих сценариев

**Требование:**
- При создании новой записи заголовок экрана должен быть "New Item"
- При редактировании существующей записи заголовок экрана должен быть "Edit Item"
- Для обоих заголовков должна быть локализация (русский и английский)

### Причина

Вероятно, в CreateEditScreen не проверяется режим работы (создание или редактирование) при формировании заголовка. Заголовок может быть захардкожен или не зависит от наличия itemId.

### Шаги исправления

#### Шаг 13.1: Анализ текущей реализации заголовка

**Задача:** Понять, как сейчас формируется заголовок на CreateEditScreen

**Действия:**
1. Изучить `CreateEditScreen.kt`:
   - Найти компонент заголовка (TopAppBar или Scaffold)
   - Проверить, как задается заголовок (хардкод или переменная)
   - Проверить, есть ли условная логика для создания/редактирования
2. Изучить навигацию:
   - Проверить, как передается itemId при редактировании
   - Проверить, как определяется режим создания/редактирования
3. Проверить наличие локализации для заголовков

#### Шаг 13.2: Добавление строк локализации

**Задача:** Добавить локализованные строки для обоих заголовков

**Действия:**
1. Добавить строковые ресурсы:
   - `res/values/strings.xml`: `new_item_title` = "New Item"
   - `res/values/strings.xml`: `edit_item_title` = "Edit Item"
   - `res/values-ru/strings.xml`: `new_item_title` = "Новая запись"
   - `res/values-ru/strings.xml`: `edit_item_title` = "Изменить запись"
2. Проверить соответствие существующему стилю локализации

#### Шаг 13.3: Реализация условного заголовка

**Задача:** Сделать заголовок зависимым от режима работы

**Действия:**
1. Добавить логику определения режима создания/редактирования:
   - Если itemId != null -> режим редактирования -> использовать `edit_item_title`
   - Если itemId == null -> режим создания -> использовать `new_item_title`
2. Обновить компонент заголовка в CreateEditScreen:
   - Использовать условную логику для выбора заголовка
   - Пример: `title = if (itemId != null) stringResource(R.string.edit_item_title) else stringResource(R.string.new_item_title)`
3. Убедиться, что заголовок корректно отображается при обоих сценариях

**Критерий готовности:**
- ✅ При создании новой записи отображается заголовок "New Item" (или "Новая запись" на русском)
- ✅ При редактировании существующей записи отображается заголовок "Edit Item" (или "Изменить запись" на русском)
- ✅ Оба заголовка локализованы на русском и английском языках
- ✅ При переключении языка заголовки корректно меняются
- ✅ Нет случаев, когда заголовок остается "New Item" при редактировании

---

## Стратегия тестирования

### Перед исправлениями

1. Запустить полный набор тестов для фиксации текущего состояния
2. Создать baseline screenshots для сравнения

### После каждого исправления

1. Проверить, что исправление решает проблему
2. Убедиться, что не появляются новые баги
3. Обновить тесты для покрытия исправлений
4. Обновить скриншоты для документации

### Финальное тестирование

1. Полное регрессионное тестирование всех функций
2. Проверка производительности
3. Проверка UX

---

## Зависимости

Эти исправления затрагивают следующие экраны и компоненты:

- **MainScreen.kt** - основной экран (баги #2, #3, #4, #5, #6, #8, #11)
- **ListItemView.kt** - компонент карточки (баги #6, #11)
- **DetailScreen.kt** - экран деталей (баги #1, #10)
- **CreateEditScreen.kt** - экран создания/редактирования (баги #9, #10, #11, #13)
- **RootScreenComponents.kt** - навигация (баги #2, #7, #11)
- **MainScreenViewModel.kt** - ViewModel (баги #3, #5, #9)
- **CreateEditScreenViewModel.kt** - ViewModel (баг #12)

---

## Критерии завершения

План считается выполненным, когда:

- ✅ Все 13 багов исправлены
- ✅ Все изменения протестированы
- ✅ Нет новых багов
- ✅ Производительность не ухудшилась
- ✅ UX улучшен

---

## История

- 2025-01-02: Создан план исправления на основе найденных 12 багов
- 2025-01-02: Добавлен баг #12 - Кнопка "Сохранить" активна без изменений
- 2025-01-02: Исправлен баг #1 - DetailScreen не обновляется после редактирования (реализовано реактивное обновление через Flow)
- 2025-01-02: Исправлен баг #2 - Toolbar перекрывает контент списка (применены paddingValues)
- 2025-01-02: Исправлен баг #7 - Нижняя навигация не видна (заменен Column на Scaffold, NavigationBar перенесена в bottomBar)
- 2025-01-02: Исправлен баг #6 - Неправильная верстка ListItemView (разделение на 70%/30%, ограничения maxLines и TextOverflow)
- 2025-01-02: Исправлен баг #8 - Контент заезжает под камеру (заменен Column на Scaffold, применены paddingValues к NavHost)
- 2025-01-02: Исправлен баг #12 - Кнопка "Сохранить" активна без изменений (реализовано отслеживание изменений через _originalItem и _hasChanges)
- 2025-01-01: Добавлен баг #13 - Заголовок экрана создания/редактирования всегда одинаковый