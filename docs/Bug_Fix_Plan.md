# План исправления багов после внедрения DI через Factory Methods

**Дата создания:** 2025-01-02  
**Статус:** НАЧАЛО РАБОТЫ

---

## Обзор проблем

После внедрения factory методов для CreateEditScreenViewModel и DetailScreenViewModel обнаружены следующие проблемы, требующие исправления:

1. ✅ **Баг #1**: DetailScreen не обновляется после редактирования (ИСПРАВЛЕН)
2. ✅ **Баг #2**: Toolbar перекрывает контент списка (ИСПРАВЛЕН)
3. ✅ **Баг #3**: Удаление записей работает некорректно (ИСПРАВЛЕН)
4. ❌ **Баг #4**: Поиск не работает
5. ❌ **Баг #5**: Пропадание записей при поиске
6. ✅ **Баг #6**: Неправильная верстка ListItemView (ИСПРАВЛЕН)
7. ✅ **Баг #7**: Нижняя навигация не видна (ИСПРАВЛЕН)
8. ✅ **Баг #8**: Контент заезжает под камеру (ИСПРАВЛЕН)
9. ✅ **Баг #9**: Изменение displayOption не обновляет UI (ИСПРАВЛЕН)
10. ✅ **Баг #10**: Свайп слева направо открывает несколько экранов редактирования (ИСПРАВЛЕН)
11. ✅ **Баг #11**: Состояние свайпа не сбрасывается при отмене удаления в диалоговом окне (ИСПРАВЛЕН)
12. ✅ **Баг #12**: Кнопка "Сохранить" активна без изменений (ИСПРАВЛЕН)
13. ❌ **Баг #13**: Заголовок экрана создания/редактирования всегда одинаковый
14. ❌ **Баг #14**: Месяцы игнорируются в MONTH_DAY и YEAR_MONTH_DAY
15. ❌ **Баг #15**: DetailScreen игнорирует displayOption

---

| Баг | Приоритет | Влияние | Сложность | Оценка |
|------|------------|-----------|----------|----------|---------|
| #1   | Высокий    | Высокое   | Средняя   | 2-3 ч   |
| #2   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #3   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #4   | Высокий    | Высокое   | Средняя    | 2-3 ч    |
| #5   | Высокий    | Высокое   | Средняя    | 2-4 ч    |
| #6   | Средний    | Среднее   | Низкая    | 1 ч       |
| #7   | Средний    | Среднее   | Низкая    | 1 ч       |
| #8   | Средний    | Среднее   | Низкая    | 1-2 ч     |
| #9   | Низкий     | Низкое    | Низкая    | 1-2 ч     |
| #10  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #11  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #12  | Средний    | Среднее   | Средняя   | 2-3 ч     |
| #13  | Низкий     | Низкое    | Низкая    | 0.5-1 ч   |
| #14  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #15  | Высокий    | Высокое   | Низкая    | 1-2 ч     |

---

## Баг #1: DetailScreen не обновляется после редактирования ✅ **ИСПРАВЛЕН**

### Описание
При возврате с экрана редактирования на DetailScreen отображались старые данные вместо актуальных.

### Решение
Добавлены методы `getItemByIdFlow()` в ItemDao и `getItemFlow()` в ItemRepository. DetailScreenViewModel переписан для использования Flow вместо однократной загрузки. Flow с SharingStarted.WhileSubscribed(5000) обеспечивает автоматическую перезагрузку при появлении экрана.

**Критерий готовности:**
- ✅ DetailScreen показывает обновленные данные сразу после возврата
- ✅ Автоматическое обновление через Flow работает
- ✅ Проблема кэширования решена

**Дата исправления: 2025-01-02**

---

## Баг #2: Toolbar перекрывает контент списка ✅ **ИСПРАВЛЕН**

### Описание
Список записей на главном экране перекрывался верхним тулбаром.

### Решение
Добавлен параметр `paddingValues`, применено `contentPadding` к `LazyColumn` и в функциях с пустым контентом.

**Критерий готовности:**
- ✅ Список записей отображается полностью
- ✅ AppBar не перекрывает контент списка

**Дата исправления: 2025-01-02**

---

## Баг #3: Удаление записей работает некорректно ✅ **ИСПРАВЛЕН**

### Описание
Вместо свайпа реализовано долгое нажатие с контекстным меню для устранения проблем с состоянием свайпа.

### Решение
Долгое нажатие открывает DropdownMenu с опциями View, Edit, Delete. Меню позиционируется в месте нажатия. При открытии контекстного меню элемент подсвечивается с плавной анимацией цвета фона.

**Критерий готовности:**
- ✅ Удаление записей работает через долгое нажатие
- ✅ При долгом нажатии открывается контекстное меню
- ✅ Элемент подсвечивается при открытии меню
- ✅ Анимация выделения работает плавно
- ✅ Контекстное меню позиционируется в месте нажатия

**Дата исправления: 2025-01-02**

---

## Баг #4: Поиск не работает

### Описание
При вводе в поиск названий записей ничего не происходит.

### Причина
SearchBar может не отправлять запрос в ViewModel при нажатии Enter. Отсутствует явная обработка события подтверждения поиска.

### Шаги исправления

#### Шаг 4.1: Анализ SearchBar ✅
Изучена текущая реализация SearchBar в MainScreen.kt: параметры, обработка `onQueryChange` и `onSearch`.

#### Шаг 4.2: Исправление обработки поиска
**Задача:** Обеспечить работу поиска

**Действия:**
1. Добавить обработку `onActiveChange` для отслеживания состояния фокуса
2. При потере фокуса выполнять поиск
3. Добавить обработку нажатия Enter
4. Убедиться, что фильтрация работает для всех записей

**Критерий готовности:**
- ✅ Поиск работает при вводе текста
- ✅ Поиск выполняется при нажатии на Enter
- ✅ Результаты поиска отображаются корректно

---

## Баг #5: Пропадание записей при поиске

### Описание

**Проблема 1 (пропадание записей):**
Иногда при переходе в режим поиска и обратно, или при нажатии на плюс для создания новой записи внезапно пропадают почти все записи с главного экрана кроме одной, а потом могут появиться при очередном появлении главного экрана - например, если нажать на иконку поиска, ввести что-то, а потом нажать на кнопку с плюсом, и потом вернуться назад - большинство записей не будет видно - они как будто скрыаются вертикально наверх.

**Проблема 2 (кнопка создания видна при поиске):**
Кнопка с плюсом (которая открывает экран создания записи) остается видимой при переходе в режим поиска, что может привести к путанице и конфликтам состояний.

**Требование:**
При переходе в режим поиска кнопку с плюсом нужно скрывать, чтобы избежать смешивания состояний "поиска" и "создания записи". Кнопка должна быть видна только когда поиск не активен.

### Причина

Проблема в управлении состоянием Flow и UI:

1. **Конфликт состояний при поиске:**
   - При активном поиске фильтрация может конфликтовать с другим состоянием
   - При создании новой записи при активном поиске происходит сброс состояния
   - Отсутствует правильное сохранение состояния при навигации между экранами

2. **Кнопка создания не учитывает состояние поиска:**
   - Кнопка с плюсом всегда видима на MainScreen
   - Нет проверки на активный режим поиска
   - Пользователь может нажать плюс при активном поиске, что вызывает путаницу

### Шаги исправления

#### Шаг 5.1: Анализ потока данных

**Задача:** Понять причину пропадания записей и проверить состояние кнопки

**Действия:**
1. Изучить `MainScreenViewModel.observeItems()`
2. Проверить логику фильтрации
3. Проверить состояние `searchQuery` при навигации
4. Проверить сохранение состояния при создании новой записи
5. Изучить верстку MainScreen.kt и найти кнопку с плюсом
6. Проверить, есть ли состояние для активного режима поиска в ViewModel

#### Шаг 5.2: Исправление управления состоянием

**Задача 1:** Сохранять состояние поиска правильно

**Действия:**
1. Сохранять состояние поиска при навигации на DetailScreen
2. Сохранять состояние поиска при навигации на CreateEditScreen
3. Восстанавливать состояние при возврате на MainScreen
4. Убедиться, что состояние не сбрасывается неожиданно

**Задача 2:** Скрыть кнопку создания при активном поиске

**Действия:**
1. Добавить состояние для отслеживания активного режима поиска в MainScreenViewModel (если нет)
2. Передать это состояние в UI MainScreen
3. В верстке MainScreen.kt добавить условие видимости для кнопки с плюсом:
   - Показывать кнопку только когда `!isSearchActive`
   - Или использовать флаг/переменную для управления видимостью
4. Проверить, что при выходе из режима поиска кнопка снова становится видимой
5. Убедиться, что скрытие кнопки не ломает навигацию и UX

**Критерий готовности:**
- ✅ При переходе к поиску записи не пропадают
- ✅ При создании новой записи состояние поиска сохраняется
- ✅ При возврате на главный экран состояние восстанавливается
- ✅ Записи отображаются корректно в любой момент
- ✅ Кнопка с плюсом скрывается при активном режиме поиска
- ✅ Кнопка с плюсом отображается когда поиск не активен
- ✅ Нет конфликтов между режимом поиска и созданием записи

---

## Баг #6: Неправильная верстка ListItemView ✅ **ВЫПОЛНЕН**

### Описание
В UI-компоненте неправильно расположены тексты: отсутствует разделение ширины, нет ограничений на количество строк.

### Решение
Разделен контент на две части (70%/30%), добавлены `maxLines = 2` и `TextOverflow.Ellipsis` для названия и описания.

**Критерий готовности:**
- ✅ Текст с количеством дней занимает не более 30% ширины
- ✅ Название и описание ограничены до 2 строк
- ✅ Длинный текст обрезается с многоточием

### Дата исправления: 2025-01-02

---

## Баг #7: Нижняя навигация не видна ✅ **ИСПРАВЛЕН**

### Описание
Нижняя панель навигации всегда была не видна.

### Решение
В RootScreen заменен `Column` на `Scaffold`, NavigationBar перенесена в параметр `bottomBar` Scaffold. Добавлена передача `paddingValues` из Scaffold в `navHostContent()`. Добавлено `contentWindowInsets = WindowInsets(0, 0, 0, 0)` для отключения автоматических отступов StatusBar.

**Критерий готовности:**
- ✅ На MainScreen видна NavigationBar с двумя вкладками
- ✅ На DetailScreen и CreateEditScreen NavigationBar скрыта
- ✅ При переключении вкладок работает корректно
- ✅ Нет лишнего пространства над заголовком экрана

### Дата исправления: 2025-01-02

---

## Баг #8: Контент заезжает под камеру ✅ **ИСПРАВЛЕН**

### Описание
При повороте экрана контент заезжал под переднюю камеру.

### Решение
В RootScreen заменен `Column` на `Scaffold` (выполнено в баге #7). Переданы `paddingValues` из Scaffold в `navHostContent()` и применены к NavHost через Modifier.padding().

**Критерий готовности:**
- ✅ Контент не заезжает под камеру
- ✅ При повороте экрана контент отображается корректно

### Дата исправления: 2025-01-02

---

## Баг #9: Изменение displayOption не обновляет UI ✅ **ИСПРАВЛЕН**

### Описание

**Проблема 1 (на CreateEditScreen):**
На экране создания/изменения записи можно выбирать display format, но его изменение не приводит к обновлению preview на этом же экране - форматирование дней остается прежним, хотя выбран другой displayOption.

**Проблема 2 (на MainScreen):**
После сохранения записи с измененным displayOption, форматирование на главном экране также остается прежним - MainScreen не пересчитывает форматирование при изменении displayOption.

**Требование:**
- При изменении displayOption на экране CreateEditScreen должен сразу обновляться preview с новым форматированием
- При сохранении записи с измененным displayOption, форматирование на MainScreen должно обновляться
- Изменения displayOption должны отражаться во всех компонентах, которые показывают форматирование дней

### Причина

Проблема в реактивном обновлении на разных экранах:

1. **На CreateEditScreen:**
   - DisplayOption хранится в состоянии ViewModel, но UI не реагирует на изменения этого поля
   - Preview на CreateEditScreen использует кэшированное значение или не подписан на изменения displayOption
   - Возможно, форматирование выполняется один раз при инициализации и не обновляется

2. **На MainScreen:**
   - DisplayOption сохраняется в записи в базе данных, но MainScreen не пересчитывает форматирование
   - ListItemView может использовать устаревшее форматирование
   - Отсутствует реактивная связь между displayOption в Item и форматированием

### Решение

**Исправлено реактивное форматирование с учетом displayOption:**

1. **На CreateEditScreen (CreateEditPreviewComponents.kt):**
   - Добавлен параметр `displayOption` в функцию `previewDaysContentInner()`
   - Созданы use cases для форматирования (`GetFormattedDaysForItemUseCase`, `FormatDaysTextUseCase`, `CalculateDaysDifferenceUseCase`)
   - Форматирование дней теперь выполняется через `GetFormattedDaysForItemUseCase` с учетом выбранного displayOption
   - Preview автоматически обновляется при изменении displayOption в UI

2. **На MainScreen (MainScreen.kt):**
   - Создан экземпляр `GetFormattedDaysForItemUseCase` при инициализации экрана
   - В `itemsListContent()` форматирование дней теперь выполняется через `getFormattedDaysForItemUseCase(item)` вместо `NumberFormattingUtils.formatDaysCount()`
   - Форматирование автоматически учитывает displayOption из каждой записи
   - При обновлении Item в базе данных (через Flow) список автоматически перерисовывается с новым форматированием

**Критерий готовности:**
- ✅ При изменении displayOption на CreateEditScreen preview обновляется немедленно
- ✅ Форматирование дней на CreateEditScreen соответствует выбранному displayOption
- ✅ При сохранении записи displayOption корректно сохраняется в базе данных
- ✅ При загрузке записи из базы displayOption присутствует и корректен
- ✅ При изменении displayOption форматирование на MainScreen обновляется автоматически
- ✅ Изменения displayOption отражаются во всех компонентах (CreateEditScreen preview, MainScreen список)
- ✅ Форматирование дней соответствует выбранному displayOption везде

**Дата исправления: 2025-01-02**

---

## Баг #10: Свайп слева направо открывает несколько экранов редактирования ✅ **ИСПРАВЛЕН**

### Описание
Свайп слева направо открывал несколько экранов редактирования подряд, создавал лишние уровни в стеке навигации.

### Решение
Свайп полностью заменен на долгое нажатие с контекстным меню. При долгом нажатии открывается DropdownMenu с опциями View, Edit, Delete. Опция "Edit" открывает только один экран редактирования с правильным заголовком, при сохранении происходит возврат на главный экран (один уровень назад).

**Критерий готовности:**
- ✅ Опция "Edit" открывает один экран редактирования
- ✅ Экран редактирования имеет правильный заголовок (с названием записи)
- ✅ При сохранении происходит возврат на главный экран (один уровень назад)
- ✅ На главном экране нет зависших иконок редактирования или выделения

---

## Баг #11: Состояние свайпа не сбрасывается при отмене удаления в диалоговом окне ✅ **ИСПРАВЛЕН**

### Описание
При отмене удаления в диалоговом окне возникали проблемы с визуальным состоянием элементов списка.

### Решение
Свайп полностью заменен на долгое нажатие с контекстным меню. При долгом нажатии открывается DropdownMenu с опциями View, Edit, Delete. Контекстное меню закрывается сразу после выбора любого действия. Нет необходимости в дополнительных действиях для сброса состояния.

**Критерий готовности:**
- ✅ При долгом нажатии открывается контекстное меню
- ✅ При отмене удаления нет проблем с визуальным состоянием
- ✅ Элемент списка возвращается в нормальное визуальное состояние
- ✅ Нет необходимости в дополнительных действиях для сброса состояния

---

## Баг #12: Кнопка "Сохранить" активна без изменений ✅ **ИСПРАВЛЕН**

### Описание

На экране редактирования существующей записи кнопка "Сохранить" активна всегда, даже если пользователь не внес никаких изменений. Кнопка должна быть недоступна (disabled), если не было изменений по сравнению с исходными данными, и доступной только при наличии изменений.

**Для новых записей логика уже корректная:**
- Кнопка "Создать" недоступна до ввода данных
- Кнопка становится доступной при наличии валидных данных

**Для редактирования существующих записей:**
- Кнопка "Сохранить" всегда активна, даже без изменений
- Нет отслеживания изменений по сравнению с исходными данными
- Пользователь может нажать "Сохранить" без реальных изменений

**Требование:**
- При открытии экрана редактирования кнопка "Сохранить" должна быть недоступна
- Кнопка должна стать доступной только когда пользователь внес изменения
- При возвращении всех полей к исходным значениям кнопка снова должна стать недоступной

### Причина

Проблема в логике отслеживания изменений в CreateEditScreenViewModel:

1. **Отсутствует сравнение с исходными данными:**
   - ViewModel не сохраняет начальное состояние записи при открытии экрана редактирования
   - Нет механизма сравнения текущих значений с исходными
   - Состояние кнопки не зависит от наличия изменений

2. **Логика для новых записей отличается:**
   - Для новых записей используется проверка на валидность данных
   - Для редактирования используется другая логика (или отсутствует)
   - Нет унифицированного подхода к управлению состоянием кнопки

### Решение

**Реализовано отслеживание изменений при редактировании:**

1. **Добавлено хранение оригинальных данных в CreateEditScreenViewModel:**
   - `private val _originalItem = MutableStateFlow<Item?>(null)` - хранит оригинальные данные записи
   - `private val _hasChanges = MutableStateFlow(false)` - отслеживает наличие изменений
   - При загрузке записи сохраняются оригинальные данные и сбрасывается флаг изменений

2. **Добавлен метод `checkHasChanges()`:**
   - Сравнивает текущие значения полей (title, details, timestamp, colorTag, displayOption) с оригинальными
   - Вызывается при каждом изменении любого поля в UI

3. **Обновлены компоненты UI для отслеживания изменений:**
   - `titleSection()` и `detailsSection()` добавлен параметр `onValueChange`
   - `colorSelector()`, `colorOptionSurface()`, `noColorOptionSurface()` добавлен параметр `onValueChange`
   - `displayOptionSelector()`, `displayOptionSurface()` добавлен параметр `onValueChange`
   - `dateSection()` добавлен параметр `onValueChange` при открытии DatePicker

4. **Обновлена логика кнопки "Сохранить" в `saveButton()`:**
   - Для новых записей: `enabled = isValidData` (проверка валидности данных)
   - Для редактирования: `enabled = isValidData && hasChanges` (валидность + наличие изменений)
   - Кнопка соблюдает разные правила для создания и редактирования

5. **Добавлен метод `resetHasChanges()`:**
   - Сбрасывает флаг изменений
   - Вызывается при успешном сохранении записи

**Критерий готовности:**
- ✅ При открытии экрана редактирования кнопка "Сохранить" недоступна
- ✅ При изменении любого поля кнопка становится доступной
- ✅ При возврате всех полей к исходным значениям кнопка снова недоступна
- ✅ Для новых записей логика кнопки "Создать" работает корректно (без изменений)
- ✅ Состояние кнопки корректно обновляется при быстрых изменениях
- ✅ Нет задержек в обновлении состояния кнопки
- ✅ После сохранения записи состояние корректно сбрасывается
- ✅ Логика работает для всех полей (title, details, timestamp, colorTag, displayOption)

**Дата исправления: 2025-01-02**

---

## Баг #13: Заголовок экрана создания/редактирования всегда одинаковый

### Описание

На экране создания/изменения записи всегда отображается одинаковый заголовок "New Item", независимо от того, создается новая запись или редактируется существующая.

**Проблема:**
- При создании новой записи заголовок должен быть "New Item" (как сейчас)
- При редактировании существующей записи заголовок должен быть "Edit Item"
- В настоящий момент заголовок всегда "New Item" для обоих сценариев

**Требование:**
- При создании новой записи заголовок экрана должен быть "New Item"
- При редактировании существующей записи заголовок экрана должен быть "Edit Item"
- Для обоих заголовков должна быть локализация (русский и английский)

### Причина

Вероятно, в CreateEditScreen не проверяется режим работы (создание или редактирование) при формировании заголовка. Заголовок может быть захардкожен или не зависит от наличия itemId.

### Шаги исправления

#### Шаг 13.1: Анализ текущей реализации заголовка

**Задача:** Понять, как сейчас формируется заголовок на CreateEditScreen

**Действия:**
1. Изучить `CreateEditScreen.kt`:
   - Найти компонент заголовка (TopAppBar или Scaffold)
   - Проверить, как задается заголовок (хардкод или переменная)
   - Проверить, есть ли условная логика для создания/редактирования
2. Изучить навигацию:
   - Проверить, как передается itemId при редактировании
   - Проверить, как определяется режим создания/редактирования
3. Проверить наличие локализации для заголовков

#### Шаг 13.2: Добавление строк локализации

**Задача:** Добавить локализованные строки для обоих заголовков

**Действия:**
1. Добавить строковые ресурсы:
   - `res/values/strings.xml`: `new_item_title` = "New Item"
   - `res/values/strings.xml`: `edit_item_title` = "Edit Item"
   - `res/values-ru/strings.xml`: `new_item_title` = "Новая запись"
   - `res/values-ru/strings.xml`: `edit_item_title` = "Изменить запись"
2. Проверить соответствие существующему стилю локализации

#### Шаг 13.3: Реализация условного заголовка

**Задача:** Сделать заголовок зависимым от режима работы

**Действия:**
1. Добавить логику определения режима создания/редактирования:
   - Если itemId != null -> режим редактирования -> использовать `edit_item_title`
   - Если itemId == null -> режим создания -> использовать `new_item_title`
2. Обновить компонент заголовка в CreateEditScreen:
   - Использовать условную логику для выбора заголовка
   - Пример: `title = if (itemId != null) stringResource(R.string.edit_item_title) else stringResource(R.string.new_item_title)`
3. Убедиться, что заголовок корректно отображается при обоих сценариях

**Критерий готовности:**
- ✅ При создании новой записи отображается заголовок "New Item" (или "Новая запись" на русском)
- ✅ При редактировании существующей записи отображается заголовок "Edit Item" (или "Изменить запись" на русском)
- ✅ Оба заголовка локализованы на русском и английском языках
- ✅ При переключении языка заголовки корректно меняются
- ✅ Нет случаев, когда заголовок остается "New Item" при редактировании

---

## Баг #14: Месяцы игнорируются в MONTH_DAY и YEAR_MONTH_DAY

### Описание

При выборе DisplayOption.MONTH_DAY или DisplayOption.YEAR_MONTH_DAY месяцы игнорируются и не отображаются.

**Пример:**
- При разнице 389 дней:
  - При выборе DAY: "389 дней" ✅
  - При выборе MONTH_DAY: должно быть "12 мес 18 дн", но показывается "389 дней" ❌
  - При выборе YEAR_MONTH_DAY: должно быть "1 г 18 дн" (потому что нет целого месяца), но показывается "389 дней" ❌

**Требование:**
- При выборе MONTH_DAY должны отображаться месяцы и дни (например, "12 мес 18 дн")
- При выборе YEAR_MONTH_DAY должны отображаться годы, месяцы и дни (например, "1 г 18 дн")
- Логика должна соответствовать iOS-приложению (источник истины)

### Причина

Проблема в вычислении TimePeriod или в его использовании при форматировании:

1. **CalculateDaysDifferenceUseCase** может неправильно вычислять месяцы в TimePeriod
2. **TimePeriod** может содержать некорректные значения месяцев
3. **FormatDaysTextUseCase** или **DaysFormatterImpl** могут игнорировать месяцы при форматировании
4. Возможно, используется только totalDays вместо периодов с месяцами

**Источник истины:**
iOS-приложение (SwiftUI-Days) имеет тесты DisplayOptionTests.swift, которые определяют правильную логику:
- DisplayOption.day: всегда .full формат
- DisplayOption.monthDay: .short когда есть месяцы и дни одновременно, иначе .full
- DisplayOption.yearMonthDay: .abbreviated когда все три значения, .short когда два, .full когда ноль или одно значение

### Шаги исправления

#### Шаг 14.1: Анализ вычисления TimePeriod

**Задача:** Понять, как сейчас вычисляются годы, месяцы и дни

**Действия:**
1. Изучить `CalculateDaysDifferenceUseCase`:
   - Проверить, как вычисляется разница между датами
   - Проверить, как создается TimePeriod
   - Проверить, корректно ли вычисляются месяцы
2. Изучить `TimePeriod`:
   - Проверить поля (years, months, days)
   - Проверить, что они вычисляются корректно
3. Сравнить с iOS-реализацией:
   - Найти аналогичную логику в iOS-приложении
   - Проверить, соответствует ли логика Android iOS
4. Добавить unit-тесты для CalculateDaysDifferenceUseCase:
   - Тест для MONTH_DAY: убедиться, что месяцы вычисляются
   - Тест для YEAR_MONTH_DAY: убедиться, что годы и месяцы вычисляются

#### Шаг 14.2: Анализ форматирования с месяцами

**Задача:** Проверить, как DaysFormatter использует месяцы при форматировании

**Действия:**
1. Изучить `DaysFormatterImpl.formatComposite()`:
   - Проверить логику для MONTH_DAY
   - Проверить логику для YEAR_MONTH_DAY
   - Проверить, что используются period.months и period.years
2. Изучить `DaysFormatterImpl.formatMonthDay()`:
   - Проверить, что месяцы добавляются в список компонентов
   - Проверить условия showMonths и showDays
3. Изучить `DaysFormatterImpl.formatYearMonthDay()`:
   - Проверить, что годы, месяцы и дни добавляются в список компонентов
4. Добавить unit-тесты для DaysFormatterImpl:
   - Тест formatMonthDay с различными комбинациями
   - Тест formatYearMonthDay с различными комбинациями
   - Убедиться, что месяцы включаются в результат

#### Шаг 14.3: Сравнение с iOS-логикой

**Задача:** Реализовать логику, соответствующую iOS

**Действия:**
1. Изучить `DisplayOptionTests.swift`:
   - Понять логику unitsStyle() в iOS
   - Понять, когда использовать .abbreviated, .short, .full
2. Проверить тестовые данные из iOS:
   - monthDayShortCombos: когда MONTH_DAY должен быть .short
   - monthDayFullCombos: когда MONTH_DAY должен быть .full
   - ymdAbbreviatedCombos: когда YEAR_MONTH_DAY должен быть .abbreviated
   - ymdShortCombos: когда YEAR_MONTH_DAY должен быть .short
   - ymdFullCombos: когда YEAR_MONTH_DAY должен быть .full
3. Реализовать аналогичную логику в Android:
   - Добавить метод в DisplayOption для выбора формата
   - Или реализовать логику внутри DaysFormatterImpl
4. Добавить тесты, соответствующие iOS-тестам:
   - Все тесты из DisplayOptionTests.swift

#### Шаг 14.4: Проверка интеграции

**Задача:** Убедиться, что форматирование работает во всех местах

**Действия:**
1. Проверить `CreateEditPreviewComponents`:
   - Убедиться, что preview использует правильное форматирование
   - Проверить все три DisplayOption
2. Проверить `MainScreen`:
   - Убедиться, что список использует правильное форматирование
   - Проверить все три DisplayOption
3. Проверить `DetailScreen`:
   - Убедиться, что детали используют правильное форматирование (если использует)
   - Проверить все три DisplayOption

**Критерий готовности:**
- ✅ При выборе MONTH_DAY отображаются месяцы и дни (например, "12 мес 18 дн")
- ✅ При выборе YEAR_MONTH_DAY отображаются годы, месяцы и дни (например, "1 г 18 дн")
- ✅ При выборе DAY отображается только общее количество дней (например, "389 дней")
- ✅ Форматирование соответствует iOS-приложению для всех DisplayOption
- ✅ Unit-тесты покрывают все сценарии из iOS-тестов
- ✅ Форматирование работает корректно на CreateEditScreen preview
- ✅ Форматирование работает корректно на MainScreen в списке
- ✅ TimePeriod вычисляет корректные значения years, months, days
- ✅ DaysFormatterImpl использует все компоненты TimePeriod

---

## Баг #15: DetailScreen игнорирует displayOption

### Описание

На экране DetailScreen displayOption игнорируется и всегда отображается только количество дней в формате N дней, независимо от выбранного displayOption в записи.

**Проблема:**
- DetailScreen использует `NumberFormattingUtils.formatDaysCount()` для форматирования
- Функция `calculateDaysText()` в DetailContent.kt не учитывает displayOption
- Даже если в Item установлено MONTH_DAY или YEAR_MONTH_DAY, на DetailScreen показываются только дни

**Требование:**
- При displayOption = DAY: отображать только дни (например, "389 дней")
- При displayOption = MONTH_DAY: отображать месяцы и дни (например, "12 мес 18 дн")
- При displayOption = YEAR_MONTH_DAY: отображать годы, месяцы и дни (например, "1 г 18 дн")
- Форматирование должно соответствовать выбранному displayOption в Item

### Причина

DetailScreen использует упрощенное форматирование:

1. **Функция calculateDaysText()** в DetailContent.kt:
   - Вычисляет totalDays через ChronoUnit.DAYS.between()
   - Использует NumberFormattingUtils.formatDaysCount(totalDays)
   - Не использует GetFormattedDaysForItemUseCase
   - Не учитывает displayOption из Item

2. **daysCountSection()** не получает displayOption:
   - Принимает только item
   - Не передает displayOption в форматирование
   - Не использует существующие use cases для форматирования

### Шаги исправления

#### Шаг 15.1: Анализ текущей реализации DetailScreen

**Задача:** Понять, как сейчас форматируется количество дней на DetailScreen

**Действия:**
1. Изучить `DetailContent.kt`:
   - Найти функцию `daysCountSection()`
   - Изучить `calculateDaysText()`
   - Проверить, что использует NumberFormattingUtils.formatDaysCount()
2. Изучить `DetailScreenViewModel`:
   - Проверить, какие use cases используются
   - Проверить, есть ли GetFormattedDaysForItemUseCase
3. Изучить навигацию и передачу Item:
   - Проверить, как Item передается в DetailContent
   - Проверить, что displayOption присутствует в Item

#### Шаг 15.2: Интеграция GetFormattedDaysForItemUseCase в DetailScreen

**Задача:** Использовать существующий use case для форматирования на DetailScreen

**Действия:**
1. Добавить GetFormattedDaysForItemUseCase в DetailScreenViewModel:
   - Создать use case через FormatterModule
   - Добавить как параметр ViewModel или создать внутри
2. Обновить DetailContent.kt:
   - Заменить `calculateDaysText()` на использование `GetFormattedDaysForItemUseCase`
   - Обновить `daysCountSection()` для использования item.makeDaysCount()
3. Убедиться, что displayOption используется:
   - GetFormattedDaysForItemUseCase автоматически использует item.displayOption
   - Форматирование учитывает выбранную опцию

#### Шаг 15.3: Удаление устаревшего кода

**Задача:** Убрать NumberFormattingUtils.formatDaysCount() из DetailScreen

**Действия:**
1. Удалить функцию `calculateDaysText()` из DetailContent.kt
2. Обновить импорты (убрать NumberFormattingUtils, если не используется)
3. Убедиться, что нет других мест, где используется NumberFormattingUtils для форматирования дней на DetailScreen

#### Шаг 15.4: Тестирование

**Задача:** Проверить, что форматирование работает для всех DisplayOption

**Действия:**
1. Создать unit-тесты для DetailContent:
   - Тест для displayOption = DAY
   - Тест для displayOption = MONTH_DAY
   - Тест для displayOption = YEAR_MONTH_DAY
2. Вручную протестировать на эмуляторе:
   - Создать запись с каждым displayOption
   - Открыть DetailScreen для каждой записи
   - Проверить, что форматирование соответствует выбранному displayOption
3. Убедиться, что секция с информацией о displayOption корректно отображается:
   - Проверить displayOptionInfoSection()
   - Убедиться, что она показывает правильное значение

**Критерий готовности:**
- ✅ При displayOption = DAY на DetailScreen отображается только количество дней
- ✅ При displayOption = MONTH_DAY на DetailScreen отображаются месяцы и дни
- ✅ При displayOption = YEAR_MONTH_DAY на DetailScreen отображаются годы, месяцы и дни
- ✅ Форматирование на DetailScreen соответствует выбранному displayOption в Item
- ✅ Форматирование на DetailScreen соответствует форматированию на MainScreen и CreateEditScreen
- ✅ NumberFormattingUtils.formatDaysCount() больше не используется для форматирования дней
- ✅ Unit-тесты покрывают все три DisplayOption
- ✅ Секция displayOptionInfoSection показывает корректное значение displayOption

---

## Стратегия тестирования

### Перед исправлениями

1. Запустить полный набор тестов для фиксации текущего состояния
2. Создать baseline screenshots для сравнения

### После каждого исправления

1. Проверить, что исправление решает проблему
2. Убедиться, что не появляются новые баги
3. Обновить тесты для покрытия исправлений
4. Обновить скриншоты для документации

### Финальное тестирование

1. Полное регрессионное тестирование всех функций
2. Проверка производительности
3. Проверка UX

---

## Зависимости

Эти исправления затрагивают следующие экраны и компоненты:

- **MainScreen.kt** - основной экран (баги #2, #3, #4, #5, #6, #8, #11, #14)
- **ListItemView.kt** - компонент карточки (баги #6, #11, #14)
- **DetailScreen.kt** - экран деталей (баги #1, #10, #15)
- **CreateEditScreen.kt** - экран создания/редактирования (баги #9, #10, #11, #13, #14)
- **RootScreenComponents.kt** - навигация (баги #2, #7, #11)
- **MainScreenViewModel.kt** - ViewModel (баги #3, #5, #9, #14)
- **CreateEditScreenViewModel.kt** - ViewModel (баг #12)
- **DetailContent.kt** - компонент деталей (баг #15)
- **DaysFormatterImpl.kt** - форматирование (баг #14)
- **CalculateDaysDifferenceUseCase.kt** - вычисление разницы дат (баг #14)
- **FormatDaysTextUseCase.kt** - форматирование текста (баг #14)
- **GetFormattedDaysForItemUseCase.kt** - получение форматированного текста (баг #14)
- **DisplayOption.kt** - модель опции отображения (баг #14)
- **TimePeriod.kt** - модель периода времени (баг #14)

---

## Критерии завершения

План считается выполненным, когда:

- ✅ Все 15 багов исправлены
- ✅ Все изменения протестированы
- ✅ Нет новых багов
- ✅ Производительность не ухудшилась
- ✅ UX улучшен

---

## История

- 2025-01-02: Создан план исправления на основе найденных 12 багов
- 2025-01-02: Добавлен баг #12 - Кнопка "Сохранить" активна без изменений
- 2025-01-02: Исправлен баг #1 - DetailScreen не обновляется после редактирования (реализовано реактивное обновление через Flow)
- 2025-01-02: Исправлен баг #2 - Toolbar перекрывает контент списка (применены paddingValues)
- 2025-01-02: Исправлен баг #7 - Нижняя навигация не видна (заменен Column на Scaffold, NavigationBar перенесена в bottomBar)
- 2025-01-02: Исправлен баг #6 - Неправильная верстка ListItemView (разделение на 70%/30%, ограничения maxLines и TextOverflow)
- 2025-01-02: Исправлен баг #8 - Контент заезжает под камеру (заменен Column на Scaffold, применены paddingValues к NavHost)
- 2025-01-02: Исправлен баг #12 - Кнопка "Сохранить" активна без изменений (реализовано отслеживание изменений через _originalItem и _hasChanges)
- 2025-01-01: Добавлен баг #13 - Заголовок экрана создания/редактирования всегда одинаковый
- 2025-01-02: Исправлен баг #9 - Изменение displayOption не обновляет UI (реализовано реактивное форматирование через GetFormattedDaysForItemUseCase)
- 2025-01-02: Добавлен баг #14 - Месяцы игнорируются в MONTH_DAY и YEAR_MONTH_DAY
- 2025-01-02: Добавлен баг #15 - DetailScreen игнорирует displayOption