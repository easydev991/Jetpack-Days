# План исправления багов после внедрения DI через Factory Methods

**Дата создания:** 2025-01-02  
**Статус:** НАЧАЛО РАБОТЫ

---

## Обзор проблем

После внедрения factory методов для CreateEditScreenViewModel и DetailScreenViewModel обнаружены следующие проблемы, требующие исправления:

1. ✅ **Баг #1**: DetailScreen не обновляется после редактирования (ИСПРАВЛЕН)
2. ✅ **Баг #2**: Toolbar перекрывает контент списка (ИСПРАВЛЕН)
3. ✅ **Баг #3**: Удаление записей работает некорректно (ИСПРАВЛЕН)
4. ❌ **Баг #4**: Поиск не работает
5. ❌ **Баг #5**: Пропадание записей при поиске
6. ✅ **Баг #6**: Неправильная верстка ListItemView (ИСПРАВЛЕН)
7. ✅ **Баг #7**: Нижняя навигация не видна (ИСПРАВЛЕН)
8. ✅ **Баг #8**: Контент заезжает под камеру (ИСПРАВЛЕН)
9. ❌ **Баг #9**: Изменение displayOption не обновляет UI
10. ✅ **Баг #10**: Свайп слева направо открывает несколько экранов редактирования (ИСПРАВЛЕН)
11. ✅ **Баг #11**: Состояние свайпа не сбрасывается при отмене удаления в диалоговом окне (ИСПРАВЛЕН)
12. ✅ **Баг #12**: Кнопка "Сохранить" активна без изменений (ИСПРАВЛЕН)

---

| Баг | Приоритет | Влияние | Сложность | Оценка |
|------|------------|-----------|----------|----------|---------|
| #1   | Высокий    | Высокое   | Средняя   | 2-3 ч   |
| #2   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #3   | Высокий    | Высокое   | Низкая    | 1-2 ч    |
| #4   | Высокий    | Высокое   | Средняя    | 2-3 ч    |
| #5   | Высокий    | Высокое   | Средняя    | 2-4 ч    |
| #6   | Средний    | Среднее   | Низкая    | 1 ч       |
| #7   | Средний    | Среднее   | Низкая    | 1 ч       |
| #8   | Средний    | Среднее   | Низкая    | 1-2 ч     |
| #9   | Низкий     | Низкое    | Низкая    | 1-2 ч     |
| #10  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #11  | Высокий    | Высокое   | Средняя   | 2-3 ч     |
| #12  | Средний    | Среднее   | Средняя   | 2-3 ч     |

---

## Баг #1: DetailScreen не обновляется после редактирования ✅ **ИСПРАВЛЕН**

### Описание
При возврате с экрана редактирования на DetailScreen отображались старые данные вместо актуальных.

### Решение
Добавлены методы `getItemByIdFlow()` в ItemDao и `getItemFlow()` в ItemRepository. DetailScreenViewModel переписан для использования Flow вместо однократной загрузки. Flow с SharingStarted.WhileSubscribed(5000) обеспечивает автоматическую перезагрузку при появлении экрана.

**Критерий готовности:**
- ✅ DetailScreen показывает обновленные данные сразу после возврата
- ✅ Автоматическое обновление через Flow работает
- ✅ Проблема кэширования решена

**Дата исправления: 2025-01-02**

---

## Баг #2: Toolbar перекрывает контент списка ✅ **ИСПРАВЛЕН**

### Описание
Список записей на главном экране перекрывался верхним тулбаром.

### Решение
Добавлен параметр `paddingValues`, применено `contentPadding` к `LazyColumn` и в функциях с пустым контентом.

**Критерий готовности:**
- ✅ Список записей отображается полностью
- ✅ AppBar не перекрывает контент списка

**Дата исправления: 2025-01-02**

---

## Баг #3: Удаление записей работает некорректно ✅ **ИСПРАВЛЕН**

### Описание
Вместо свайпа реализовано долгое нажатие с контекстным меню для устранения проблем с состоянием свайпа.

### Решение
Долгое нажатие открывает DropdownMenu с опциями View, Edit, Delete. Меню позиционируется в месте нажатия. При открытии контекстного меню элемент подсвечивается с плавной анимацией цвета фона.

**Критерий готовности:**
- ✅ Удаление записей работает через долгое нажатие
- ✅ При долгом нажатии открывается контекстное меню
- ✅ Элемент подсвечивается при открытии меню
- ✅ Анимация выделения работает плавно
- ✅ Контекстное меню позиционируется в месте нажатия

**Дата исправления: 2025-01-02**

---

## Баг #4: Поиск не работает

### Описание
При вводе в поиск названий записей ничего не происходит.

### Причина
SearchBar может не отправлять запрос в ViewModel при нажатии Enter. Отсутствует явная обработка события подтверждения поиска.

### Шаги исправления

#### Шаг 4.1: Анализ SearchBar ✅
Изучена текущая реализация SearchBar в MainScreen.kt: параметры, обработка `onQueryChange` и `onSearch`.

#### Шаг 4.2: Исправление обработки поиска
**Задача:** Обеспечить работу поиска

**Действия:**
1. Добавить обработку `onActiveChange` для отслеживания состояния фокуса
2. При потере фокуса выполнять поиск
3. Добавить обработку нажатия Enter
4. Убедиться, что фильтрация работает для всех записей

**Критерий готовности:**
- ✅ Поиск работает при вводе текста
- ✅ Поиск выполняется при нажатии на Enter
- ✅ Результаты поиска отображаются корректно

---

## Баг #5: Пропадание записей при поиске

### Описание

**Проблема 1 (пропадание записей):**
Иногда при переходе в режим поиска и обратно, или при нажатии на плюс для создания новой записи внезапно пропадают почти все записи с главного экрана кроме одной, а потом могут появиться при очередном появлении главного экрана - например, если нажать на иконку поиска, ввести что-то, а потом нажать на кнопку с плюсом, и потом вернуться назад - большинство записей не будет видно - они как будто скрыаются вертикально наверх.

**Проблема 2 (кнопка создания видна при поиске):**
Кнопка с плюсом (которая открывает экран создания записи) остается видимой при переходе в режим поиска, что может привести к путанице и конфликтам состояний.

**Требование:**
При переходе в режим поиска кнопку с плюсом нужно скрывать, чтобы избежать смешивания состояний "поиска" и "создания записи". Кнопка должна быть видна только когда поиск не активен.

### Причина

Проблема в управлении состоянием Flow и UI:

1. **Конфликт состояний при поиске:**
   - При активном поиске фильтрация может конфликтовать с другим состоянием
   - При создании новой записи при активном поиске происходит сброс состояния
   - Отсутствует правильное сохранение состояния при навигации между экранами

2. **Кнопка создания не учитывает состояние поиска:**
   - Кнопка с плюсом всегда видима на MainScreen
   - Нет проверки на активный режим поиска
   - Пользователь может нажать плюс при активном поиске, что вызывает путаницу

### Шаги исправления

#### Шаг 5.1: Анализ потока данных

**Задача:** Понять причину пропадания записей и проверить состояние кнопки

**Действия:**
1. Изучить `MainScreenViewModel.observeItems()`
2. Проверить логику фильтрации
3. Проверить состояние `searchQuery` при навигации
4. Проверить сохранение состояния при создании новой записи
5. Изучить верстку MainScreen.kt и найти кнопку с плюсом
6. Проверить, есть ли состояние для активного режима поиска в ViewModel

#### Шаг 5.2: Исправление управления состоянием

**Задача 1:** Сохранять состояние поиска правильно

**Действия:**
1. Сохранять состояние поиска при навигации на DetailScreen
2. Сохранять состояние поиска при навигации на CreateEditScreen
3. Восстанавливать состояние при возврате на MainScreen
4. Убедиться, что состояние не сбрасывается неожиданно

**Задача 2:** Скрыть кнопку создания при активном поиске

**Действия:**
1. Добавить состояние для отслеживания активного режима поиска в MainScreenViewModel (если нет)
2. Передать это состояние в UI MainScreen
3. В верстке MainScreen.kt добавить условие видимости для кнопки с плюсом:
   - Показывать кнопку только когда `!isSearchActive`
   - Или использовать флаг/переменную для управления видимостью
4. Проверить, что при выходе из режима поиска кнопка снова становится видимой
5. Убедиться, что скрытие кнопки не ломает навигацию и UX

**Критерий готовности:**
- ✅ При переходе к поиску записи не пропадают
- ✅ При создании новой записи состояние поиска сохраняется
- ✅ При возврате на главный экран состояние восстанавливается
- ✅ Записи отображаются корректно в любой момент
- ✅ Кнопка с плюсом скрывается при активном режиме поиска
- ✅ Кнопка с плюсом отображается когда поиск не активен
- ✅ Нет конфликтов между режимом поиска и созданием записи

---

## Баг #6: Неправильная верстка ListItemView ✅ **ВЫПОЛНЕН**

### Описание
В UI-компоненте неправильно расположены тексты: отсутствует разделение ширины, нет ограничений на количество строк.

### Решение
Разделен контент на две части (70%/30%), добавлены `maxLines = 2` и `TextOverflow.Ellipsis` для названия и описания.

**Критерий готовности:**
- ✅ Текст с количеством дней занимает не более 30% ширины
- ✅ Название и описание ограничены до 2 строк
- ✅ Длинный текст обрезается с многоточием

### Дата исправления: 2025-01-02

---

## Баг #7: Нижняя навигация не видна ✅ **ИСПРАВЛЕН**

### Описание
Нижняя панель навигации всегда была не видна.

### Решение
В RootScreen заменен `Column` на `Scaffold`, NavigationBar перенесена в параметр `bottomBar` Scaffold. Добавлена передача `paddingValues` из Scaffold в `navHostContent()`. Добавлено `contentWindowInsets = WindowInsets(0, 0, 0, 0)` для отключения автоматических отступов StatusBar.

**Критерий готовности:**
- ✅ На MainScreen видна NavigationBar с двумя вкладками
- ✅ На DetailScreen и CreateEditScreen NavigationBar скрыта
- ✅ При переключении вкладок работает корректно
- ✅ Нет лишнего пространства над заголовком экрана

### Дата исправления: 2025-01-02

---

## Баг #8: Контент заезжает под камеру ✅ **ИСПРАВЛЕН**

### Описание
При повороте экрана контент заезжал под переднюю камеру.

### Решение
В RootScreen заменен `Column` на `Scaffold` (выполнено в баге #7). Переданы `paddingValues` из Scaffold в `navHostContent()` и применены к NavHost через Modifier.padding().

**Критерий готовности:**
- ✅ Контент не заезжает под камеру
- ✅ При повороте экрана контент отображается корректно

### Дата исправления: 2025-01-02

---

## Баг #9: Изменение displayOption не обновляет UI

### Описание

**Проблема 1 (на CreateEditScreen):**
На экране создания/изменения записи можно выбирать display format, но его изменение не приводит к обновлению preview на этом же экране - форматирование дней остается прежним, хотя выбран другой displayOption.

**Проблема 2 (на MainScreen):**
После сохранения записи с измененным displayOption, форматирование на главном экране также остается прежним - MainScreen не пересчитывает форматирование при изменении displayOption.

**Требование:**
- При изменении displayOption на экране CreateEditScreen должен сразу обновляться preview с новым форматированием
- При сохранении записи с измененным displayOption, форматирование на MainScreen должно обновляться
- Изменения displayOption должны отражаться во всех компонентах, которые показывают форматирование дней

### Причина

Проблема в реактивном обновлении на разных экранах:

1. **На CreateEditScreen:**
   - DisplayOption хранится в состоянии ViewModel, но UI не реагирует на изменения этого поля
   - Preview на CreateEditScreen использует кэшированное значение или не подписан на изменения displayOption
   - Возможно, форматирование выполняется один раз при инициализации и не обновляется

2. **На MainScreen:**
   - DisplayOption сохраняется в записи в базе данных, но MainScreen не пересчитывает форматирование
   - ListItemView может использовать устаревшее форматирование
   - Отсутствует реактивная связь между displayOption в Item и форматированием

### Шаги исправления

#### Шаг 9.1: Анализ потока данных на CreateEditScreen

**Задача:** Понять, почему displayOption не обновляет preview на CreateEditScreen

**Действия:**
1. Изучить `CreateEditScreenViewModel.kt`:
   - Проверить, где хранится displayOption (в состоянии ViewModel)
   - Проверить, есть ли StateFlow для displayOption
   - Проверить, как displayOption используется для форматирования в preview
2. Изучить `CreateEditScreen.kt`:
   - Проверить, как UI подписан на изменения displayOption
   - Проверить, как форматируется preview (однократно или реактивно)
   - Проверить, используется ли `collectAsState()` для displayOption
3. Проверить, есть ли вызов метода форматирования при изменении displayOption

#### Шаг 9.2: Анализ потока данных на MainScreen

**Задача:** Понять, почему displayOption не обновляет форматирование на MainScreen

**Действия:**
1. Изучить `MainScreenViewModel` и форматирование дней:
   - Проверить, как displayOption используется из Item
   - Проверить, где происходит форматирование (в ViewModel или в UI)
2. Проверить `ListItemView.kt`:
   - Проверить, как displayOption используется для форматирования
   - Проверить, откуда берется displayOption для каждой записи
   - Проверить, что форматирование выполняется при каждом изменении Item
3. Проверить Item сущность:
   - Убедиться, что displayOption корректно сохраняется в базе данных
   - Проверить, что при загрузке из базы displayOption не теряется

#### Шаг 9.3: Исправление форматирования на CreateEditScreen

**Задача:** Обеспечить реактивное обновление preview при изменении displayOption

**Действия:**
1. Убедиться, что CreateEditScreenViewModel использует StateFlow для displayOption:
```kotlin
// В CreateEditScreenViewModel
val displayOption: StateFlow<DisplayOption> = _displayOption.asStateFlow()
private val _displayOption = MutableStateFlow<InitialValue)
```

2. Проверить, что CreateEditScreen подписан на изменения displayOption:
```kotlin
// В CreateEditScreen
val displayOption by viewModel.displayOption.collectAsState()
// Использовать displayOption для форматирования preview
```

3. Убедиться, что при каждом изменении displayOption происходит пересчет форматирования в preview
4. Проверить, что компонент preview перерисовывается при изменении displayOption

#### Шаг 9.4: Исправление форматирования на MainScreen

**Задача:** Обеспечить корректное форматирование при изменении displayOption

**Действия:**
1. Убедиться, что displayOption сохраняется корректно при создании/редактировании записи
2. Проверить, что при загрузке Item из базы данных displayOption присутствует
3. Убедиться, что MainScreen использует Flow для получения списка записей (для автоматического обновления)
4. Проверить, что ListItemView использует displayOption из Item для форматирования
5. Убедиться, что при изменении Item в базе данных (включая displayOption) список перерисовывается с новым форматированием

#### Шаг 9.5: Проверка сохранения и загрузки displayOption

**Задача:** Убедиться, что displayOption корректно сохраняется и загружается

**Действия:**
1. Проверить Item сущность:
   - Убедиться, что displayOption поле корректно определено
   - Проверить, что displayOption включено в Room таблицу
2. Проверить ItemDao:
   - Убедиться, что при сохранении записи displayOption сохраняется
   - Проверить, что при загрузке записи displayOption загружается
3. Проверить ItemRepository:
   - Убедиться, что displayOption не теряется при передаче данных

**Критерий готовности:**
- ✅ При изменении displayOption на CreateEditScreen preview обновляется немедленно
- ✅ Форматирование дней на CreateEditScreen соответствует выбранному displayOption
- ✅ При сохранении записи displayOption корректно сохраняется в базе данных
- ✅ При загрузке записи из базы displayOption присутствует и корректен
- ✅ При изменении displayOption форматирование на MainScreen обновляется автоматически
- ✅ Изменения displayOption отражаются во всех компонентах (CreateEditScreen preview, MainScreen список)
- ✅ Форматирование дней соответствует выбранному displayOption везде

---

## Баг #10: Свайп слева направо открывает несколько экранов редактирования ✅ **ИСПРАВЛЕН**

### Описание
Свайп слева направо открывал несколько экранов редактирования подряд, создавал лишние уровни в стеке навигации.

### Решение
Свайп полностью заменен на долгое нажатие с контекстным меню. При долгом нажатии открывается DropdownMenu с опциями View, Edit, Delete. Опция "Edit" открывает только один экран редактирования с правильным заголовком, при сохранении происходит возврат на главный экран (один уровень назад).

**Критерий готовности:**
- ✅ Опция "Edit" открывает один экран редактирования
- ✅ Экран редактирования имеет правильный заголовок (с названием записи)
- ✅ При сохранении происходит возврат на главный экран (один уровень назад)
- ✅ На главном экране нет зависших иконок редактирования или выделения

---

## Баг #11: Состояние свайпа не сбрасывается при отмене удаления в диалоговом окне ✅ **ИСПРАВЛЕН**

### Описание
При отмене удаления в диалоговом окне возникали проблемы с визуальным состоянием элементов списка.

### Решение
Свайп полностью заменен на долгое нажатие с контекстным меню. При долгом нажатии открывается DropdownMenu с опциями View, Edit, Delete. Контекстное меню закрывается сразу после выбора любого действия. Нет необходимости в дополнительных действиях для сброса состояния.

**Критерий готовности:**
- ✅ При долгом нажатии открывается контекстное меню
- ✅ При отмене удаления нет проблем с визуальным состоянием
- ✅ Элемент списка возвращается в нормальное визуальное состояние
- ✅ Нет необходимости в дополнительных действиях для сброса состояния

---

## Баг #12: Кнопка "Сохранить" активна без изменений ✅ **ИСПРАВЛЕН**

### Описание

На экране редактирования существующей записи кнопка "Сохранить" активна всегда, даже если пользователь не внес никаких изменений. Кнопка должна быть недоступна (disabled), если не было изменений по сравнению с исходными данными, и доступной только при наличии изменений.

**Для новых записей логика уже корректная:**
- Кнопка "Создать" недоступна до ввода данных
- Кнопка становится доступной при наличии валидных данных

**Для редактирования существующих записей:**
- Кнопка "Сохранить" всегда активна, даже без изменений
- Нет отслеживания изменений по сравнению с исходными данными
- Пользователь может нажать "Сохранить" без реальных изменений

**Требование:**
- При открытии экрана редактирования кнопка "Сохранить" должна быть недоступна
- Кнопка должна стать доступной только когда пользователь внес изменения
- При возвращении всех полей к исходным значениям кнопка снова должна стать недоступной

### Причина

Проблема в логике отслеживания изменений в CreateEditScreenViewModel:

1. **Отсутствует сравнение с исходными данными:**
   - ViewModel не сохраняет начальное состояние записи при открытии экрана редактирования
   - Нет механизма сравнения текущих значений с исходными
   - Состояние кнопки не зависит от наличия изменений

2. **Логика для новых записей отличается:**
   - Для новых записей используется проверка на валидность данных
   - Для редактирования используется другая логика (или отсутствует)
   - Нет унифицированного подхода к управлению состоянием кнопки

### Решение

**Реализовано отслеживание изменений при редактировании:**

1. **Добавлено хранение оригинальных данных в CreateEditScreenViewModel:**
   - `private val _originalItem = MutableStateFlow<Item?>(null)` - хранит оригинальные данные записи
   - `private val _hasChanges = MutableStateFlow(false)` - отслеживает наличие изменений
   - При загрузке записи сохраняются оригинальные данные и сбрасывается флаг изменений

2. **Добавлен метод `checkHasChanges()`:**
   - Сравнивает текущие значения полей (title, details, timestamp, colorTag, displayOption) с оригинальными
   - Вызывается при каждом изменении любого поля в UI

3. **Обновлены компоненты UI для отслеживания изменений:**
   - `titleSection()` и `detailsSection()` добавлен параметр `onValueChange`
   - `colorSelector()`, `colorOptionSurface()`, `noColorOptionSurface()` добавлен параметр `onValueChange`
   - `displayOptionSelector()`, `displayOptionSurface()` добавлен параметр `onValueChange`
   - `dateSection()` добавлен параметр `onValueChange` при открытии DatePicker

4. **Обновлена логика кнопки "Сохранить" в `saveButton()`:**
   - Для новых записей: `enabled = isValidData` (проверка валидности данных)
   - Для редактирования: `enabled = isValidData && hasChanges` (валидность + наличие изменений)
   - Кнопка соблюдает разные правила для создания и редактирования

5. **Добавлен метод `resetHasChanges()`:**
   - Сбрасывает флаг изменений
   - Вызывается при успешном сохранении записи

**Критерий готовности:**
- ✅ При открытии экрана редактирования кнопка "Сохранить" недоступна
- ✅ При изменении любого поля кнопка становится доступной
- ✅ При возврате всех полей к исходным значениям кнопка снова недоступна
- ✅ Для новых записей логика кнопки "Создать" работает корректно (без изменений)
- ✅ Состояние кнопки корректно обновляется при быстрых изменениях
- ✅ Нет задержек в обновлении состояния кнопки
- ✅ После сохранения записи состояние корректно сбрасывается
- ✅ Логика работает для всех полей (title, details, timestamp, colorTag, displayOption)

**Дата исправления: 2025-01-02**

---

## Стратегия тестирования

### Перед исправлениями

1. Запустить полный набор тестов для фиксации текущего состояния
2. Создать baseline screenshots для сравнения

### После каждого исправления

1. Проверить, что исправление решает проблему
2. Убедиться, что не появляются новые баги
3. Обновить тесты для покрытия исправлений
4. Обновить скриншоты для документации

### Финальное тестирование

1. Полное регрессионное тестирование всех функций
2. Проверка производительности
3. Проверка UX

---

## Зависимости

Эти исправления затрагивают следующие экраны и компоненты:

- **MainScreen.kt** - основной экран (баги #2, #3, #4, #5, #6, #8, #11)
- **ListItemView.kt** - компонент карточки (баги #6, #11)
- **DetailScreen.kt** - экран деталей (баги #1, #10)
- **CreateEditScreen.kt** - экран создания/редактирования (баги #9, #10, #11)
- **RootScreenComponents.kt** - навигация (баги #2, #7, #11)
- **MainScreenViewModel.kt** - ViewModel (баги #3, #5, #9)
- **CreateEditScreenViewModel.kt** - ViewModel (баг #12)

---

## Критерии завершения

План считается выполненным, когда:

- ✅ Все 12 багов исправлены
- ✅ Все изменения протестированы
- ✅ Нет новых багов
- ✅ Производительность не ухудшилась
- ✅ UX улучшен

---

## История

- 2025-01-02: Создан план исправления на основе найденных 12 багов
- 2025-01-02: Добавлен баг #12 - Кнопка "Сохранить" активна без изменений
- 2025-01-02: Исправлен баг #1 - DetailScreen не обновляется после редактирования (реализовано реактивное обновление через Flow)
- 2025-01-02: Исправлен баг #2 - Toolbar перекрывает контент списка (применены paddingValues)
- 2025-01-02: Исправлен баг #7 - Нижняя навигация не видна (заменен Column на Scaffold, NavigationBar перенесена в bottomBar)
- 2025-01-02: Исправлен баг #6 - Неправильная верстка ListItemView (разделение на 70%/30%, ограничения maxLines и TextOverflow)
- 2025-01-02: Исправлен баг #8 - Контент заезжает под камеру (заменен Column на Scaffold, применены paddingValues к NavHost)
- 2025-01-02: Исправлен баг #12 - Кнопка "Сохранить" активна без изменений (реализовано отслеживание изменений через _originalItem и _hasChanges)