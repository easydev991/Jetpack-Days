# Экран 4.1: Create/Edit Item Screen (Создание и редактирование записей)

## Обзор

Create/Edit Item Screen предназначен для создания новой записи или редактирования существующей. Экран предоставляет форму ввода всех данных записи с валидацией и обработкой ошибок.

## Назначение

Создание новой записи или редактирование существующей с валидацией данных и сохранением в базу данных.

## Компоненты

1. **Заголовок экрана** (navigationTitle, navigationBarTitleDisplayMode: inline)
   - Для создания: "Новая запись"
   - Для редактирования: "Редактировать"
2. **Поле ввода "Название"** (EditSectionView)
   - Заголовок: "Название" (SectionTitleView)
   - Placeholder: "Название для записи"
   - Обязательное поле
   - Автофокус при открытии экрана (FocusState)
3. **Поле ввода "Описание"** (EditSectionView)
   - Заголовок: "Описание" (SectionTitleView)
   - Placeholder: "Описание для записи"
   - Многострочное текстовое поле
   - Необязательное поле
4. **Выбор даты** (ItemDatePicker)
   - Заголовок: "Дата" (SectionTitleView)
   - DatePicker с выбором даты (displayedComponents: date)
   - По умолчанию: текущая дата
5. **Цветовая метка**
   - Toggle: "Добавить цветовую метку" (SectionTitleView)
   - При включении — показывается ColorPicker с анимацией (transition: move + opacity)
   - При выключении — скрывается ColorPicker
   - По умолчанию: выключено (colorTag = null)
   - При включении: colorTag = .yellow (по умолчанию)
6. **Опция отображения дней** (ItemDisplayOptionPicker)
   - Заголовок: "Формат отображения" (SectionTitleView)
   - Picker с опциями:
     - "Только дни" (day)
     - "Дни и месяцы" (monthDay)
     - "Годы, месяцы и дни" (yearMonthDay)
   - По умолчанию: "Только дни" (day)

## Кнопки на Toolbar

- **Кнопка "Отмена" / "Закрыть"** (placement: topBarLeading)
  - Для создания: "Закрыть" (возвращает к списку)
  - Для редактирования: "Отмена" (возвращает к просмотру записи)
  - При редактировании: navigationBarBackButtonHidden = true
- **Кнопка "Сохранить"** (placement: topBarTrailing)
  - Активна только если:
    - Название не пустое
    - При редактировании: есть изменения (сравнение всех полей)

## Валидация

- Название не может быть пустым
- При редактировании кнопка "Сохранить" активна только если данные изменились

## Навигация

- Кнопка "Отмена/Закрыть" → возврат к предыдущему экрану
- Кнопка "Сохранить" → сохранение данных и возврат к предыдущему экрану

## Зависимости от других этапов

- ⚠️ **Требуется Этап 7**: Модель данных (Entity, Domain model, Room Database, DAO) — необходимо для сохранения данных записи
- ⚠️ **Требуется Экран 2.1**: Main Screen — должен быть реализован для навигации к экрану создания/редактирования
- ⚠️ **Требуется Экран 3.1**: Item Screen — должен быть реализован для навигации к экрану редактирования (опционально)

---

## Подробный план реализации по TDD

### Шаг 1: Подготовка слоя домена (Domain Layer)

#### 1.1. Use Cases

**Задачи:**
1. Создать CreateItemUseCase для создания новой записи
   - Принимает данные формы (title, details, timestamp, colorTag, displayOption)
   - Валидирует обязательные поля
   - Сохраняет запись через Repository
2. Создать UpdateItemUseCase для обновления существующей записи
   - Принимает ID записи и новые данные
   - Проверяет наличие изменений
   - Обновляет запись через Repository
3. Создать GetItemByIdUseCase для получения записи при редактировании
   - Принимает ID записи
   - Возвращает данные записи или null
4. Написать unit-тесты для Use Cases (MockK для Repository)

**Критерии готовности:**
- ✅ Use Cases созданы
- ✅ Валидация реализована
- ✅ Unit-тесты написаны и проходят

---

### Шаг 2: Подготовка слоя представления (Presentation Layer)

#### 2.1. UI State

**Задачи:**
1. Создать data class CreateEditItemUiState для состояния формы
   - Поля: title, details, timestamp, colorTag, displayOption, isColorTagEnabled
   - Методы для определения изменений при редактировании
2. Создать sealed class CreateEditItemScreenState для состояний экрана
   - Loading, Success, Error
3. Написать unit-тесты для UI State

**Структура:**
```kotlin
sealed class CreateEditItemScreenUiState {
    object Loading : CreateEditItemScreenUiState()
    object Success : CreateEditItemScreenUiState()
    data class Error(val message: String) : CreateEditItemScreenUiState()
}

data class CreateEditItemUiState(
    val title: String = "",
    val details: String = "",
    val timestamp: Long = System.currentTimeMillis(),
    val colorTag: Int? = null,
    val displayOption: DisplayOption = DisplayOption.DEFAULT,
    val isColorTagEnabled: Boolean = false,
    val originalItem: Item? = null,
    val screenState: CreateEditItemScreenUiState = CreateEditItemScreenUiState.Loading
) {
    fun hasChanges(): Boolean {
        // Сравнение с originalItem
    }
    
    fun isValid(): Boolean {
        return title.isNotBlank()
    }
}
```

**Критерии готовности:**
- ✅ UI State создан
- ✅ Методы валидации реализованы
- ✅ Unit-тесты написаны и проходят

---

#### 2.2. ViewModel

**Задачи:**
1. Создать CreateEditItemViewModel
   - Управление состоянием формы (title, details, timestamp, colorTag, displayOption)
   - Логика валидации (проверка обязательного поля "Название")
   - Определение изменений при редактировании
   - Обработка событий: сохранение, отмена, изменение полей
   - Использование Use Cases для бизнес-логики
   - Обработка ошибок и состояний загрузки
2. Написать unit-тесты для ViewModel (MockK для Use Cases)

**Критерии готовности:**
- ✅ ViewModel создан
- ✅ Все методы реализованы
- ✅ Валидация работает
- ✅ Unit-тесты написаны и проходят

---

### Шаг 3: Реализация UI компонентов

#### 3.1. Навигация

**Задачи:**
1. Добавить маршрут в Screen.kt
   - Для создания: `object CreateItem : Screen("create_item", icon, R.string.new_item)`
   - Для редактирования: `object EditItem : Screen("edit_item/{itemId}", icon, R.string.edit_item)`
   - Использовать `titleResId` для локализации заголовков экранов
2. Настроить навигацию из Main Screen (кнопка "+")
3. Настроить навигацию из Item Screen (кнопка "Редактировать")

**Критерии готовности:**
- ✅ Маршруты добавлены
- ✅ Навигация настроена

---

#### 3.2. Форма ввода данных

**Задачи:**
1. Создать EditItemScreen composable (аналог iOS EditItemScreen)
2. Реализовать Toolbar с кнопками "Отмена/Закрыть" и "Сохранить"
   - Разные тексты кнопок для режимов создания/редактирования
   - Активация кнопки "Сохранить" только при валидных данных
   - При редактировании: скрыть стандартную кнопку "Назад"
3. Реализовать поле ввода "Название" (EditSectionView)
   - TextField с заголовком (SectionTitleView) и placeholder
   - Автофокус при открытии экрана (FocusState)
   - Валидация (не может быть пустым)
4. Реализовать поле ввода "Описание" (EditSectionView)
   - Многострочное TextField с заголовком (SectionTitleView) и placeholder
   - Необязательное поле
5. Реализовать DatePicker для выбора даты события (ItemDatePicker)
   - Заголовок "Дата" (SectionTitleView)
   - По умолчанию: текущая дата
   - Интеграция с Material Design 3 DatePicker (displayedComponents: date)
6. Реализовать Toggle для включения цветовой метки
   - Заголовок "Добавить цветовую метку" (SectionTitleView)
   - По умолчанию: выключено (colorTag = null)
   - При включении: colorTag = желтый по умолчанию
   - Показ/скрытие ColorPicker при переключении с анимацией (transition: move + opacity)
7. Реализовать ColorPicker
   - Визуальное отображение выбранного цвета
   - Интеграция с Material Design 3 ColorPicker
8. Реализовать выбор опции отображения дней (ItemDisplayOptionPicker)
   - Заголовок "Формат отображения" (SectionTitleView)
   - Picker с опциями (как в iOS):
     - "Только дни" (day)
     - "Дни и месяцы" (monthDay)
     - "Годы, месяцы и дни" (yearMonthDay)
   - По умолчанию: "Только дни" (day)

**Критерии готовности:**
- ✅ Все компоненты формы созданы
- ✅ Валидация работает
- ✅ Все поля работают корректно

---

#### 3.3. Верстка компонентов

**Задачи:**
1. Использовать ScrollView для прокрутки формы (scrollBounceBehavior: basedOnSize)
2. Использовать вертикальный VStack для основного макета (spacing: 20dp, alignment: leading)
3. Обеспечить корректные отступы между элементами формы (padding: 16dp)
4. Обеспечить адекватное отображение элементов при изменении ориентации экрана
5. Обеспечить корректное поведение при вводе текста и выборе даты
6. Применить тему приложения с поддержкой темного режима
7. Применить корректные иконки из Material Icons
8. Верстка идентична iOS для единообразия UX

**Критерии готовности:**
- ✅ Верстка выполнена
- ✅ Адаптивность обеспечена

---

### Шаг 4: Интеграция и обработка ошибок

#### 4.1. Сохранение данных

**Задачи:**
1. Реализовать логику сохранения через ViewModel
   - Вызов CreateItemUseCase при создании
   - Вызов UpdateItemUseCase при редактировании
   - Обработка успешного сохранения (возврат к предыдущему экрану)
2. Реализовать обработку ошибок сохранения
   - Отображение сообщения об ошибке пользователю
   - Логирование ошибок

**Критерии готовности:**
- ✅ Сохранение работает
- ✅ Обработка ошибок реализована

---

#### 4.2. Загрузка данных при редактировании

**Задачи:**
1. Реализовать загрузку данных записи при открытии экрана редактирования
   - Вызов GetItemByIdUseCase
   - Заполнение формы данными записи
   - Обработка случая, когда запись не найдена

**Критерии готовности:**
- ✅ Загрузка данных работает
- ✅ Обработка ошибок реализована

---

#### 4.3. Определение изменений

**Задачи:**
1. Реализовать логику определения изменений при редактировании
   - Сравнение текущих значений формы с исходными данными записи
   - Активация кнопки "Сохранить" только при наличии изменений

**Критерии готовности:**
- ✅ Определение изменений работает
- ✅ Кнопка "Сохранить" активируется корректно

---

### Шаг 5: Локализация

**Задачи:**
1. Использовать готовые строковые ресурсы из `Localization_Plan.md`:
   - Заголовки экрана: `new_item`, `edit_item`
   - Заголовки полей: `title`, `details`, `date`, `color_tag`, `display_format`
   - Placeholder тексты: `title_for_the_item`, `details_for_the_item`
   - Опции отображения дней: `days_only`, `months_and_days`, `years_months_and_days`
   - Кнопки: `save`, `cancel`, `close`, `add_color_tag`
2. Поддержка русского и английского языков (уже реализована в `Localization_Plan.md`)

**Критерии готовности:**
- ✅ Используются готовые строковые ресурсы
- ✅ Локализация работает корректно

**Примечание:** План локализации готов в документе `Localization_Plan.md`. Все строки определены и готовы к использованию.

---

### Шаг 6: Финальное тестирование

**Задачи:**
1. Проверить отображение формы в режиме создания (UI тесты)
2. Проверить отображение формы в режиме редактирования (UI тесты)
3. Проверить валидацию поля "Название" (unit + UI тесты)
4. Проверить функциональность DatePicker (UI тесты)
5. Проверить включение/отключение ColorPicker через Toggle (UI тесты)
6. Проверить выбор опции отображения дней (UI тесты)
7. Проверить активацию кнопки "Сохранить" только при наличии изменений (при редактировании) (unit + UI тесты)
8. Проверить корректное сохранение данных и возврат к предыдущему экрану (UI тесты)
9. Проверить корректную работу кнопки "Отмена/Закрыть" (UI тесты)

**Критерии готовности:**
- ✅ Все тесты проходят
- ✅ Все функции работают корректно

---

## Реализация (детали)

### UI компоненты
- Использовать вертикальный Column для основного макета
- Добавить ScrollableColumn для прокрутки формы
- Реализовать поля ввода с заголовками и плейсхолдерами
- Добавить Toggle для включения цветовой метки
- Добавить ColorPicker с визуальным отображением выбранного цвета
- Обеспечить адекватное отображение элементов при изменении ориентации экрана
- Обеспечить корректное поведение при вводе текста и выборе даты
- Подключить к ViewModel для управления состоянием формы
- Использовать современные компоненты Material Design 3
- Применить тему приложения с поддержкой темного режима
- Применить корректные иконки из Material Icons

### Архитектура
- Использовать Room для локального хранения данных (через Repository)
- Реализовать Repository Pattern для абстракции источников данных
- Использовать Use Cases для бизнес-логики
- Применить Clean Architecture (Data → Domain → Presentation)
- Использовать Flow для реактивного обновления UI (если требуется)

---

## Тестирование

### Unit-тесты
- Тесты для CreateItemUseCase
  - Успешное создание записи
  - Валидация обязательных полей
  - Обработка ошибок сохранения
- Тесты для UpdateItemUseCase
  - Успешное обновление записи
  - Проверка наличия изменений
  - Обработка ошибок обновления
- Тесты для GetItemByIdUseCase
  - Успешное получение записи
  - Обработка случая, когда запись не найдена
- Тесты для CreateEditItemViewModel
  - Инициализация состояния формы
  - Валидация поля "Название"
  - Определение изменений при редактировании
  - Обработка событий сохранения
  - Обработка событий отмены
  - Обработка ошибок

### Интеграционные тесты
- Тесты взаимодействия ViewModel с Use Cases
- Тесты взаимодействия Use Cases с Repository

### UI-тесты
- Отображение формы в режиме создания
- Отображение формы в режиме редактирования
- Валидация поля "Название" (кнопка "Сохранить" неактивна при пустом поле)
- Функциональность DatePicker
- Включение/отключение ColorPicker через Toggle
- Выбор опции отображения дней
- Активация кнопки "Сохранить" только при наличии изменений (при редактировании)
- Корректное сохранение данных и возврат к предыдущему экрану
- Корректная работа кнопки "Отмена/Закрыть"

---

## Критерии завершения этапа

Этап считается завершенным, когда:

- ✅ Все компоненты созданы и работают
- ✅ Все unit-тесты написаны и проходят
- ✅ Все интеграционные тесты написаны и проходят
- ✅ Все UI-тесты написаны и проходят
- ✅ Код соответствует правилам проекта
- ✅ Линтеры не выдают ошибок
- ✅ Валидация работает корректно
- ✅ Навигация работает корректно

---

## Блокируемые этапы

После завершения этого экрана можно приступать к:
- Экран 2.1: Main Screen (требует возможность создания записей)
- Экран 3.1: Item Screen (требует возможность редактирования записей)

---

## Примечания

1. **Валидация**: Название является обязательным полем, форма не может быть сохранена без него.

2. **Определение изменений**: При редактировании кнопка "Сохранить" должна быть активна только если данные изменились.

3. **Автофокус**: Поле "Название" должно получать фокус автоматически при открытии экрана создания.

4. **Обработка ошибок**: Все ошибки сохранения должны быть обработаны и отображены пользователю.

5. **Тестирование**: Все компоненты должны быть покрыты тестами перед использованием в других этапах.

6. **Зависимости**: Реализация зависит от завершения Этапа 7 (Модель данных), Экрана 2.1 (Main Screen) и Экрана 3.1 (Item Screen).
