# Лучшие практики разработки для Android (Qwen Code)

Этот документ описывает лучшие практики разработки Android для этого проекта, следуя принципам TDD и используя современный стек технологий с минимальными зависимостями.

## Обзор проекта

Приложение "Days Counter" для отслеживания дней с момента событий. Работает полностью офлайн.

**Ключевые ограничения:**
- Офлайн режим: без сетевых функций
- Совместимость: модель резервной копии идентична iOS-приложению
- Логи: на русском языке по умолчанию
- Безопасность: не использовать `!!`, безопасно разворачивать опционалы

## Технологический стек

### Основные зависимости
- **Jetpack Compose**: UI
- **Navigation Compose**: навигация
- **ViewModel**: управление состоянием UI
- **Room**: локальная БД
- **DataStore**: простое хранение
- **Coroutines**: асинхронность
- **JUnit 5**: unit-тесты
- **MockK**: мокирование
- **Espresso**: UI тесты

**ВАЖНО:** Сетевые библиотеки (Retrofit, OkHttp, Ktor) НЕ используются.

### Зависимости проекта
Полный список зависимостей проекта находится в файле `gradle/libs.versions.toml`. Для получения актуальной информации о версиях библиотек и плагинов обращайтесь к этому файлу.

### Обновленная информация о проекте

- **AGP (Android Gradle Plugin)**: 8.13.2
- **Kotlin**: 2.0.21
- **Compile SDK**: 35
- **Target SDK**: 35
- **Min SDK**: 26
- **KSP (Kotlin Symbol Processing)**: 2.0.21-1.0.25

## Architecture

### MVVM Pattern
- **Model**: Data layer (Room, repositories)
- **View**: Compose UI
- **ViewModel**: UI state management

### Clean Architecture
```
Presentation (UI, ViewModel)
├── Domain (Use Cases, entities)
└── Data (Repositories, только локальные источники)
```

**ВАЖНО:** Нет сетевых источников данных.

## Подход TDD

### Порядок разработки: Сначала тесты и логика, потом UI
**КРИТИЧЕСКИ ВАЖНО:** Строго соблюдать порядок:

1. Тесты → 2. Логика → 3. UI

1. Писать модульные тесты для бизнес-логики перед реализацией
2. Реализовывать функциональность слоя домена и данных перед UI
3. Проверять бизнес-логику тестами перед разработкой UI
4. Создавать Compose UI только после тестирования логики

### Пирамида тестирования
- **Модульные тесты (70%)**: Тестирование отдельных функций и классов
- **Интеграционные тесты (20%)**: Тестирование взаимодействия между компонентами
- **UI тесты (10%)**: Тестирование пользовательских сценариев и критических путей

### Соглашение об именовании тестов
```kotlin
@Test
fun `functionName_whenCondition_thenExpectedResult`() {
    // Given
    // When
    // Then
}
```

### Пример модульного теста
```kotlin
class DaysCalculatorTest {
    @Test
    fun `calculateDaysDifference_whenSameDay_thenReturnsZero`() {
        // Given
        val date = LocalDate.now()

        // When
        val result = DaysCalculator.calculateDaysDifference(date, date)

        // Then
        assertEquals(0, result)
    }
}
```

### Цикл TDD

1. **Red**: Написать падающий тест
2. **Green**: Написать минимальный код для прохождения теста
3. **Refactor**: Улучшить код, сохраняя тесты зелеными

### Принципы

- Тесты пишутся первыми
- Один тест - одна проверка
- Тесты независимы друг от друга
- Тесты быстрые и читаемые

## Лучшие практики Compose

### Управление состоянием
- Использовать `State`/`MutableState` для UI состояния
- Следовать однонаправленному потоку данных
- Использовать `ViewModel` для состояния UI

### Composition Local
- Использовать `CompositionLocal` только для темы/глобальной конфигурации
- Избегать чрезмерного использования `CompositionLocal`

### Аннотации Preview
```kotlin
@Preview
@Composable
fun ComponentPreview() {
    MyAppTheme {
        Component()
    }
}
```

### Именование
- Классы: `PascalCase`
- Функции/переменные: `camelCase`
- Константы: `UPPER_SNAKE_CASE`
- Пакеты: `lowercase.with.dots`

### Комментарии
- KDoc для публичных API
- Объяснять "почему", не "что"
- Логи на русском

## Слой данных

### База данных Room
- Определять сущности с правильными аннотациями
- Использовать DAO для операций с базой данных
- Правильно обрабатывать миграции

### Паттерн Repository
- Абстрагировать источники данных
- Обрабатывать только локальные источники данных (без удаленных/сетевых источников)
- Предоставлять чистый API для use cases
- Управлять локальными операциями с базой данных и операциями импорта/экспорта файлов

## Слой домена

### Use Cases
- Инкапсулировать бизнес-логику
- Следовать принципу единственной ответственности
- Принимать параметры и возвращать результаты

### Сущности
- Простые Kotlin data классы
- Инкапсуляция бизнес-логики
- Неизменяемые по умолчанию

## Слой представления

### Руководящие принципы ViewModel
- Хранить состояние UI
- Обрабатывать пользовательские события
- Делегировать бизнес-логику use cases
- Использовать `viewModelScope` для корутин

### Состояние UI
- Представлять состояние UI в виде data классов
- Обрабатывать состояния загрузки, успеха и ошибки
- Использовать sealed классы для представления состояния

## Навигация

### Нижняя навигация
- Использовать Navigation Compose для навигации на основе вкладок
- Определять маршруты как sealed классы
- Правильно обрабатывать глубокие ссылки

### Пример структуры навигации
```kotlin
sealed class Screen(val route: String) {
    object Main : Screen("main")
    object ItemDetails : Screen("item_details/{itemId}") {
        fun createRoute(itemId: Long) = "item_details/$itemId"
    }
    object CreateEditItem : Screen("create_edit_item")
    object More : Screen("more")
    object ThemeIcon : Screen("theme_icon")
    object AppData : Screen("app_data")
}
```

## Обработка ошибок

### Глобальная обработка ошибок
- Использовать sealed классы для типов ошибок
- Обрабатывать ошибки в ViewModel
- Отображать понятные пользователю сообщения об ошибках

### Пример sealed класса для ошибок
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val message: String) : Result<Nothing>()
    object Loading : Result<Nothing>()
}
```

## Локализация

### Ресурсы строк
- Поддерживать русский (ru) и английский (en)
- Использовать описательные ключи для строк
- Правильно обрабатывать множественное число

### Пример ресурса строк
```xml
<!-- res/values/strings.xml -->
<string name="days_count_format">%d дней</string>
<string name="today">Сегодня</string>
```

## Резервное копирование и восстановление

### Формат JSON
Совместим с iOS-приложением:

```json
[
  {
    "title": "Название события",
    "details": "Описание события",
    "timestamp": 1234567890000,
    "colorTag": "#FFFF00",
    "displayOption": "day"
  }
]
```

### Правила

- Экспорт: JSON формат, метаданные версии, обработка ошибок
- Импорт: валидация JSON, проверка версии, предотвращение дубликатов, обработка ошибок
- Совместимость: формат идентичен iOS, поля совпадают по названию и типу

## Производительность и безопасность

### Производительность

#### Память
- Избегать утечек, правильная привязка к lifecycle
- `remember`/`rememberSaveable` в Compose

#### БД
- Индексы, оптимизация запросов, пагинация для больших списков

#### UI
- Избегать лишних рекомпозиций
- `key()` для стабильной идентификации элементов списков
- Lazy loading для списков

### Безопасность

#### Данные
- Шифрование конфиденциальных данных
- Проверка пользовательского ввода
- Не хранить чувствительные данные открыто

#### Файлы
- Валидация содержимого импортируемых файлов
- Ограничение размера файлов
- Безопасная обработка ошибок

## Качество кода

### Линтинг

- ktlint: `./gradlew ktlintCheck`, `./gradlew ktlintFormat`
- detekt: `./gradlew detekt` (конфиг: `config/detekt/detekt.yml`)

### Требования

- Все замечания устранены перед коммитом
- Автоисправления применяются регулярно
- Новый код не добавляет проблем

### Документация

- KDoc для публичных API
- Осмысленные имена
- Комментарии для сложной логики
- Документация актуальна

## Структура проекта

```
app/src/main/java/com/dayscounter/
├── data/
│   ├── database/      # Room entities, DAO, DB
│   ├── repository/    # Repository implementations
│   └── local/         # Local data sources
├── domain/
│   ├── model/         # Domain entities
│   ├── repository/    # Repository interfaces
│   └── usecase/       # Use cases
├── presentation/
│   ├── ui/            # Compose screens
│   ├── theme/         # App theme
│   ├── navigation/    # Navigation routes
│   └── viewmodel/     # ViewModels
└── MainActivity.kt
```

## Правила

- Экран → папка в `presentation/ui/screen/`
- ViewModel → рядом с экраном или в `presentation/viewmodel/`
- Тесты → `test/` (unit) и `androidTest/` (integration/UI)
- Структура тестов зеркалит структуру кода

## Тестирование

## Типы тестов

- **Unit**: бизнес-логика изолированно, MockK для зависимостей, AAA паттерн
- **Integration**: взаимодействие слоев, реальные реализации
- **UI**: критические сценарии, Espresso, навигация

## Инструменты

- JUnit 5 - unit-тесты
- MockK - мокирование
- Espresso - UI тесты
- Compose Testing - Compose компоненты

## Структура

- `app/src/test/` - unit-тесты
- `app/src/androidTest/` - integration/UI тесты
- Структура зеркалит код
- Имена классов: `*Test`

## Best Practices

- Быстрые и независимые тесты
- Описательные имена
- Один тест - одна проверка
- Тестировать поведение, не реализацию

## Рассмотрение CI/CD

### Процесс сборки
- Использовать Gradle для автоматизации сборки
- Реализовать покрытие кода тестами
- Запускать тесты при каждом коммите

### Контроль качества
- Поддерживать пороги покрытия кода
- Запускать инструменты статического анализа
- Выполнять сканирование безопасности

## Makefile

Для удобства работы с проектом создан Makefile с командами:

- `make build` - сборка проекта
- `make clean` - очистка кэша проекта
- `make test` - запуск unit-тестов с отображением результатов
- `make lint` - запуск линтера (ktlint и detekt)
- `make format` - форматирование кода
- `make check` - сборка, запуск тестов и линтера
- `make install` - установка приложения на устройство/эмулятор
- `make all` - выполнение всех проверок и установка приложения

Для использования команд Makefile просто выполните их в корне проекта, например:
```
make test
```
или
```
make check
```

Эти команды автоматизируют рутинные операции и упрощают процесс разработки.