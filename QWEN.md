# Лучшие практики разработки для Android (Qwen Code)

Этот документ описывает лучшие практики разработки Android для этого проекта, следуя принципам TDD и используя современный стек технологий с минимальными зависимостями.

## Обзор проекта

Это приложение "Days Counter" для отслеживания и подсчета дней, прошедших с момента важных событий. Приложение позволяет пользователям создавать записи с датами, просматривать, редактировать и удалять их, а также управлять резервными копиями данных.

**ВАЖНО:** Приложение работает полностью в автономном режиме (офлайн) без сетевых функций. Единственное взаимодействие с внешними файлами - экспорт резервных копий и импорт файлов резервных копий, аналогично iOS-приложению. Модель резервной копии должна быть совместима между iOS и Android-приложениями.

## Технологический стек

### Основные зависимости
- **Jetpack Compose**: Современный инструментарий для создания нативного Android UI
- **Navigation Compose**: Для навигации между экранами
- **ViewModel**: Для управления данными, связанными с UI
- **Room**: Для локальных операций с базой данных
- **DataStore**: Для простого хранения данных
- **Coroutines**: Для асинхронных операций
- **Hilt**: Для внедрения зависимостей
- **JUnit 5**: Для модульного тестирования
- **MockK**: Для мокирования в тестах
- **Espresso**: Для UI тестирования

**Примечание:** Сетевые библиотеки (такие как Retrofit, OkHttp или Ktor) не требуются, так как приложение работает полностью в автономном режиме.

### Зависимости проекта
Полный список зависимостей проекта находится в файле `gradle/libs.versions.toml`. Для получения актуальной информации о версиях библиотек и плагинов обращайтесь к этому файлу.

### Обновленная информация о проекте

- **AGP (Android Gradle Plugin)**: 8.13.2
- **Kotlin**: 2.1.20
- **Compile SDK**: 35
- **Target SDK**: 35
- **Min SDK**: 26
- **KSP (Kotlin Symbol Processing)**: 2.1.20-1.0.28

## Architecture

### MVVM Pattern
- **Model**: Data layer (Room database, repositories)
- **View**: Compose UI components
- **ViewModel**: Business logic and UI state management

### Слои Clean Architecture
```
Слой представления (UI, ViewModel)
├── Слой домена (Use Cases, сущности)
└── Слой данных (Репозитории, только локальные источники данных - без сети)
```

**Примечание:** Поскольку приложение работает полностью в автономном режиме, в архитектуре нет сетевых источников данных или удаленных API-слоев.

## Подход TDD

### Порядок разработки: Сначала тесты и логика, потом UI
- **Планировать и реализовывать тесты первыми**: Писать модульные тесты для бизнес-логики перед реализацией функциональности
- **Разрабатывать основную логику до UI**: Реализовывать функциональность слоя домена и слоя данных перед созданием UI-компонентов
- **Проверять бизнес-логику с помощью тестов**: Убедиться, что все бизнес-правила и вычисления тщательно протестированы перед разработкой UI
- **Добавлять UI последним**: Создавать только компоненты Compose UI после того, как вся основная логика протестирована и работает

### Пирамида тестирования
- **Модульные тесты (70%)**: Тестирование отдельных функций и классов
- **Интеграционные тесты (20%)**: Тестирование взаимодействия между компонентами
- **UI тесты (10%)**: Тестирование пользовательских сценариев и критических путей

### Соглашение об именовании тестов
```kotlin
@Test
fun `functionName_whenCondition_thenExpectedResult`() {
    // Given
    // When
    // Then
}
```

### Пример модульного теста
```kotlin
class DaysCalculatorTest {
    @Test
    fun `calculateDaysDifference_whenSameDay_thenReturnsZero`() {
        // Given
        val date = LocalDate.now()

        // When
        val result = DaysCalculator.calculateDaysDifference(date, date)

        // Then
        assertEquals(0, result)
    }
}
```

## Лучшие практики Compose

### Управление состоянием
- Использовать `State` и `MutableState` для состояния UI
- Следовать однонаправленному потоку данных
- Использовать `ViewModel` для хранения состояния UI

### Composition Local
- Использовать `CompositionLocal` для темы и глобальной конфигурации приложения
- Избегать чрезмерного использования `CompositionLocal`

### Аннотации Preview
```kotlin
@Preview
@Composable
fun ComponentPreview() {
    MyAppTheme {
        Component()
    }
}
```

## Слой данных

### База данных Room
- Определять сущности с правильными аннотациями
- Использовать DAO для операций с базой данных
- Правильно обрабатывать миграции

### Паттерн Repository
- Абстрагировать источники данных
- Обрабатывать только локальные источники данных (без удаленных/сетевых источников)
- Предоставлять чистый API для use cases
- Управлять локальными операциями с базой данных и операциями импорта/экспорта файлов

## Слой домена

### Use Cases
- Инкапсулировать бизнес-логику
- Следовать принципу единственной ответственности
- Принимать параметры и возвращать результаты

### Сущности
- Простые Kotlin data классы
- Инкапсуляция бизнес-логики
- Неизменяемые по умолчанию

## Слой представления

### Руководящие принципы ViewModel
- Хранить состояние UI
- Обрабатывать пользовательские события
- Делегировать бизнес-логику use cases
- Использовать `viewModelScope` для корутин

### Состояние UI
- Представлять состояние UI в виде data классов
- Обрабатывать состояния загрузки, успеха и ошибки
- Использовать sealed классы для представления состояния

## Навигация

### Нижняя навигация
- Использовать Navigation Compose для навигации на основе вкладок
- Определять маршруты как sealed классы
- Правильно обрабатывать глубокие ссылки

### Пример структуры навигации
```kotlin
sealed class Screen(val route: String) {
    object Main : Screen("main")
    object ItemDetails : Screen("item_details/{itemId}") {
        fun createRoute(itemId: Long) = "item_details/$itemId"
    }
    object CreateEditItem : Screen("create_edit_item")
    object More : Screen("more")
    object ThemeIcon : Screen("theme_icon")
    object AppData : Screen("app_data")
}
```

## Обработка ошибок

### Глобальная обработка ошибок
- Использовать sealed классы для типов ошибок
- Обрабатывать ошибки в ViewModel
- Отображать понятные пользователю сообщения об ошибках

### Пример sealed класса для ошибок
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val message: String) : Result<Nothing>()
    object Loading : Result<Nothing>()
}
```

## Локализация

### Ресурсы строк
- Поддерживать русский (ru) и английский (en)
- Использовать описательные ключи для строк
- Правильно обрабатывать множественное число

### Пример ресурса строк
```xml
<!-- res/values/strings.xml -->
<string name="days_count_format">%d дней</string>
<string name="today">Сегодня</string>
```

## Резервное копирование и восстановление

### Формат JSON
- Использовать согласованную структуру JSON для резервных копий
- Обрабатывать проверку данных во время восстановления
- Предотвращать дублирование записей

### Структура резервной копии
```json
[
  {
    "title": "Название события",
    "details": "Описание события",
    "timestamp": 1234567890000,
    "colorTag": "#FFFF00",
    "displayOption": "day"
  }
]
```

## Производительность

### Управление памятью
- Избегать утечек памяти
- Использовать правильную привязку к жизненному циклу
- Эффективно обрабатывать изменения конфигурации

### Производительность базы данных
- Использовать индексирование там, где это необходимо
- Оптимизировать запросы
- Эффективно обрабатывать большие наборы данных

## Безопасность

### Защита данных
- Шифровать конфиденциальные данные при необходимости
- Следовать лучшим практикам безопасности Android
- Проверять пользовательский ввод

## Качество кода

### Линтинг
- Использовать ktlint и detekt для форматирования кода и проверки качества
- Следовать соглашениям об именовании Kotlin
- Поддерживать последовательный стиль кода
- Автоматически исправлять все замечания линтеров
- Обязательно соблюдать все правила, определенные в конфигурациях ktlint и detekt

#### Настройка и использование ktlint и detekt
- **ktlint** - инструмент для проверки и форматирования стиля кода Kotlin
  - Запуск проверки: `./gradlew ktlintCheck`
  - Автоисправление: `./gradlew ktlintFormat`
  - Интегрирован в процесс сборки проекта
- **detekt** - инструмент статического анализа кода Kotlin
  - Запуск проверки: `./gradlew detekt`
  - Настраивается через файл `config/detekt/detekt.yml`
  - Обнаруживает потенциальные проблемы, сложные конструкции и т.д.

#### Требования к качеству кода
- Все замечания ktlint и detekt должны быть устранены перед коммитом
- Автоматические исправления должны применяться регулярно
- Новые фичи/багфиксы не должны добавлять новых проблем
- Код должен соответствовать стандартам, определенным в конфигурациях инструментов

### Документация
- Документировать публичные API
- Использовать осмысленные имена переменных и функций
- Добавлять комментарии для сложной логики

## Структура проекта

```
app/src/main/
├── java/com/dayscounter/
│   ├── data/
│   │   ├── database/
│   │   ├── repository/
│   │   └── local/
│   ├── domain/
│   │   ├── model/
│   │   ├── repository/
│   │   └── usecase/
│   ├── presentation/
│   │   ├── ui/
│   │   ├── theme/
│   │   ├── navigation/
│   │   └── viewmodel/
│   └── MainActivity.kt
├── res/
└── AndroidManifest.xml
```

## Стратегия тестирования

### Модульные тесты
- Тестировать бизнес-логику изолированно
- Мокировать зависимости
- Следовать шаблону AAA (Arrange, Act, Assert)

### Интеграционные тесты
- Тестировать взаимодействие между слоями
- Использовать реальные реализации, где это возможно
- Тестировать операции с базой данных

### UI тесты
- Тестировать критические пользовательские сценарии
- Использовать Espresso для инструментальных тестов
- Тестировать навигацию и изменения состояния

## Рассмотрение CI/CD

### Процесс сборки
- Использовать Gradle для автоматизации сборки
- Реализовать покрытие кода тестами
- Запускать тесты при каждом коммите

### Контроль качества
- Поддерживать пороги покрытия кода
- Запускать инструменты статического анализа
- Выполнять сканирование безопасности

## Makefile

Для удобства работы с проектом создан Makefile с командами:

- `make build` - сборка проекта
- `make clean` - очистка кэша проекта
- `make test` - запуск unit-тестов с отображением результатов
- `make lint` - запуск линтера (ktlint и detekt)
- `make format` - форматирование кода
- `make check` - сборка, запуск тестов и линтера
- `make install` - установка приложения на устройство/эмулятор
- `make all` - выполнение всех проверок и установка приложения

Для использования команд Makefile просто выполните их в корне проекта, например:
```
make test
```
или
```
make check
```

Эти команды автоматизируют рутинные операции и упрощают процесс разработки.